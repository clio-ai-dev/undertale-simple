<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Open World RPG</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #111; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: 'Press Start 2P', monospace; overflow: hidden; }
  canvas { image-rendering: pixelated; touch-action: none; max-width: 100vw; max-height: 70vh; }
  #touch-controls { display: none; position: fixed; bottom: 8px; left: 0; right: 0; padding: 8px 16px; z-index: 10; }
  @media (pointer: coarse) { #touch-controls { display: flex; justify-content: space-between; align-items: flex-end; } }
  .dpad { display: grid; grid-template: 46px 46px 46px / 46px 46px 46px; gap: 3px; }
  .dpad button, .action-buttons button { background: rgba(255,255,255,0.12); border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; color: #fff; font-family: 'Press Start 2P', monospace; font-size: 16px; -webkit-user-select: none; user-select: none; touch-action: manipulation; }
  .dpad button:active, .action-buttons button:active { background: rgba(255,255,255,0.3); }
  .dpad .up { grid-column: 2; grid-row: 1; } .dpad .left { grid-column: 1; grid-row: 2; } .dpad .right { grid-column: 3; grid-row: 2; } .dpad .down { grid-column: 2; grid-row: 3; }
  .action-buttons { display: flex; flex-direction: column; gap: 6px; }
  .action-buttons button { width: 58px; height: 58px; border-radius: 50%; font-size: 14px; }
  .btn-z { background: rgba(255,80,80,0.25) !important; border-color: #f66 !important; }
  .btn-x { background: rgba(80,80,255,0.25) !important; border-color: #88f !important; }
</style>
</head>
<body>
<canvas id="game" width="640" height="480"></canvas>
<div id="touch-controls">
  <div class="dpad">
    <button class="up" data-key="ArrowUp">▲</button>
    <button class="left" data-key="ArrowLeft">◀</button>
    <button class="right" data-key="ArrowRight">▶</button>
    <button class="down" data-key="ArrowDown">▼</button>
  </div>
  <div class="action-buttons">
    <button class="btn-z" data-key="z">Z</button>
    <button class="btn-x" data-key="x">X</button>
  </div>
</div>
<script>
const C = document.getElementById('game');
const ctx = C.getContext('2d');
const W = 640, H = 480, T = 32; // tile size

// ── Audio ──
const ac = new (window.AudioContext || window.webkitAudioContext)();
function resumeAC() { if (ac.state === 'suspended') ac.resume(); }
document.addEventListener('touchstart', resumeAC, { once: true });
document.addEventListener('keydown', resumeAC, { once: true });
function tone(f, d, type='square', v=0.12) {
  const o = ac.createOscillator(), g = ac.createGain();
  o.type = type; o.frequency.value = f;
  g.gain.setValueAtTime(v, ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + d);
  o.connect(g); g.connect(ac.destination); o.start(); o.stop(ac.currentTime + d);
}
function sfxStep() { tone(200 + Math.random()*50, 0.04, 'triangle', 0.04); }
function sfxSelect() { tone(600, 0.06); }
function sfxConfirm() { tone(800, 0.05); setTimeout(()=>tone(1200,0.08),50); }
function sfxHit() { tone(180, 0.12, 'sawtooth', 0.18); }
function sfxHurt() { tone(120, 0.2, 'sawtooth', 0.2); }
function sfxHeal() { [500,700,900].forEach((f,i) => setTimeout(()=>tone(f,0.08),i*70)); }
function sfxPickup() { tone(900,0.06); setTimeout(()=>tone(1300,0.1),60); }
function sfxDeath() { [400,300,200,100].forEach((f,i) => setTimeout(()=>tone(f,0.2,'sawtooth',0.18),i*180)); }
function sfxLevelUp() { [523,659,784,1047,1319].forEach((f,i) => setTimeout(()=>tone(f,0.12,'square',0.1),i*100)); }
function sfxDoor() { tone(300,0.1,'triangle',0.1); setTimeout(()=>tone(500,0.12,'triangle',0.1),100); }

// Ambient music
let bgmI = null, bgmN = 0;
const bgmMel = [262,294,330,349,392,349,330,294,262,247,220,247,262,330,392,440];
function startBgm(notes) { stopBgm(); bgmN=0; bgmI=setInterval(()=>{tone((notes||bgmMel)[bgmN%(notes||bgmMel).length],0.14,'triangle',0.04);bgmN++;},280); }
function stopBgm() { if(bgmI){clearInterval(bgmI);bgmI=null;} }

// ── Input ──
const keys = {}, jp = {};
document.addEventListener('keydown', e => { jp[e.key] = !keys[e.key]; keys[e.key] = true; e.preventDefault(); });
document.addEventListener('keyup', e => { keys[e.key] = false; });
document.querySelectorAll('[data-key]').forEach(b => {
  const k = b.dataset.key;
  b.addEventListener('touchstart', e => { e.preventDefault(); jp[k] = !keys[k]; keys[k] = true; });
  b.addEventListener('touchend', e => { e.preventDefault(); keys[k] = false; });
  b.addEventListener('touchcancel', () => keys[k] = false);
});
function clearJP() { for (const k in jp) delete jp[k]; }

// ── World Generation ──
// Tiles: 0=floor, 1=wall, 2=water, 3=save point, 4=pillar, 5=dark wall, 6=path, 7=bridge, 8=flowers, 9=ice, 10=lava, 11=crystal, 12=tall grass
const ZONES = {
  ruins:    { w:80, h:50, bg:'#2a0845', music:[262,294,330,294,262,247,220,247,262,330,349,330] },
  snowdin:  { w:90, h:35, bg:'#1a1a3a', music:[330,392,440,392,330,294,262,294,330,349,392,440] },
  waterfall:{ w:70, h:55, bg:'#0a1a3a', music:[220,262,294,330,294,262,220,196,175,196,220,262] },
  hotland:  { w:60, h:50, bg:'#2a0a0a', music:[440,494,523,494,440,392,349,392,440,523,587,523] },
};

const TILE_COLORS = {
  0:'#555', 1:'#222', 2:'#1a4a8a', 3:'#ff0', 4:'#444',
  5:'#1a1a2e', 6:'#6a5a4a', 7:'#5a4a3a', 8:'#555',
  9:'#8ab4e8', 10:'#c44', 11:'#48c', 12:'#3a6a3a',
};

const maps = {};
const npcs = {};
const items = {};
const portals = {};
const enemySpawns = {};

function genMap(id) {
  const z = ZONES[id];
  const m = Array.from({length: z.h}, () => new Array(z.w).fill(1)); // all walls

  // Helper: carve a room
  const room = (x,y,w,h,tile=0) => { for(let dy=0;dy<h;dy++) for(let dx=0;dx<w;dx++) if(y+dy<z.h&&x+dx<z.w) m[y+dy][x+dx]=tile; };
  // Helper: carve a corridor
  const corH = (x1,x2,y,w=2) => { for(let x=Math.min(x1,x2);x<=Math.max(x1,x2);x++) for(let dy=0;dy<w;dy++) if(y+dy<z.h) m[y+dy][x]=0; };
  const corV = (y1,y2,x,w=2) => { for(let y=Math.min(y1,y2);y<=Math.max(y1,y2);y++) for(let dx=0;dx<w;dx++) if(x+dx<z.w) m[y][x+dx]=0; };
  // Helper: add pillars in a room
  const pillars = (rx,ry,rw,rh,spacing=4) => {
    for(let x=rx+2;x<rx+rw-1;x+=spacing) for(let y=ry+2;y<ry+rh-1;y+=spacing) m[y][x]=4;
  };

  if (id === 'ruins') {
    // === THE RUINS (purple, pillared rooms, long corridors) ===
    // Starting room (flower bed)
    room(35,2,10,8); m[5][40]=8; m[6][40]=8; m[5][39]=8; m[5][41]=8; // flower patch
    // Long corridor south
    corV(9,18,39,2);
    // Puzzle room 1 (wide with pillars)
    room(30,18,20,10); pillars(30,18,20,10,5);
    // Corridor west
    corH(15,30,22,2);
    // Room with leaves
    room(5,18,12,10);
    for(let i=0;i<8;i++) m[22+Math.floor(Math.random()*4)][7+Math.floor(Math.random()*8)]=8;
    // Long corridor south from puzzle room
    corV(27,38,39,2);
    // Large pillar hall
    room(25,34,25,12); pillars(25,34,25,12,4);
    // Small rooms branching east
    corH(49,58,38,2);
    room(55,34,10,10);
    // Save point
    m[37][57]=3;
    // Corridor south to exit
    corV(45,49,38,3);
    // Spider room (west branch)
    corH(8,25,38,2);
    room(2,34,10,10);
    // Toriel's home
    room(60,4,16,14);
    room(63,7,10,8,0); // interior
    corH(49,60,10,2); // corridor to home
    m[8][68]=3; // save point at home

    portals.ruins = [
      { x:39, y:49, to:'snowdin', tx:3, ty:17, label:'Snowdin' },
      { x:68, y:17, to:'snowdin', tx:3, ty:17, label:'Snowdin (shortcut)' },
    ];
    npcs.ruins = [
      { x:40, y:4, name:'Flowey', dialog:['Howdy! I\'m FLOWEY.\nFLOWEY the FLOWER!','In this world...\nit\'s KILL or BE KILLED!','...that\'s just a\njoke! Hee hee.'], idx:0, color:'#ff0' },
      { x:65, y:9, name:'Toriel', dialog:['Welcome, my child.\nThis is your new home.','I have made a\nbutterscotch pie.','Be careful in the\nrooms ahead.'], idx:0, color:'#fff', healer:true },
      { x:7, y:22, name:'Froggit', dialog:['Ribbit ribbit.\n(Life is hard.)','Ribbit.\n(But you seem nice.)'], idx:0, color:'#4a4' },
    ];
    items.ruins = [
      { x:35, y:20, name:'Toy Knife', type:'weapon', atk:3, taken:false },
      { x:8, y:36, name:'Spider Cider', type:'heal', hp:24, taken:false },
      { x:57, y:37, name:'Faded Ribbon', type:'armor', def:3, taken:false },
      { x:40, y:5, name:'Monster Candy', type:'heal', hp:10, taken:false },
    ];
    enemySpawns.ruins = [
      { x:35, y:24, name:'Froggit', hp:15, atk:4, exp:10, gold:5, color:'#4a4', respawn:200 },
      { x:12, y:22, name:'Whimsun', hp:10, atk:3, exp:8, gold:4, color:'#dbd', respawn:180 },
      { x:42, y:40, name:'Moldsmal', hp:20, atk:5, exp:12, gold:6, color:'#8a8', respawn:220 },
      { x:56, y:38, name:'Loox', hp:25, atk:6, exp:15, gold:8, color:'#c84', respawn:250 },
      { x:6, y:38, name:'Vegetoid', hp:18, atk:5, exp:10, gold:7, color:'#6a4', respawn:200 },
    ];
  }

  if (id === 'snowdin') {
    // === SNOWDIN (horizontal, icy, town at the end) ===
    // Long horizontal path with branching areas
    // Main corridor
    corH(0,89,15,4);
    // Entry room
    room(1,10,10,12);
    // Forest area 1
    room(14,8,14,14,0);
    // Scatter some trees (pillars)
    for(let i=0;i<12;i++) { const tx=15+Math.floor(Math.random()*12), ty=9+Math.floor(Math.random()*12); m[ty][tx]=4; }
    // Ice puzzle area
    room(32,8,16,16,9); // ice tiles
    room(34,10,12,12,9);
    m[14][35]=0; m[14][36]=0; // gaps in ice
    m[18][42]=0; m[18][43]=0;
    // Corridor continues
    corV(7,15,48,2);
    room(46,3,10,6);
    // Papyrus puzzle room
    room(54,10,16,12);
    corH(48,54,15,2);
    // Place some ice
    for(let y=12;y<20;y+=2) for(let x=56;x<68;x+=3) m[y][x]=9;
    // Snowdin Town
    room(72,8,16,20);
    corH(69,72,16,2);
    // Buildings in town
    room(74,10,5,4,1); m[13][76]=0; // shop (enter from bottom)
    room(81,10,5,4,1); m[13][83]=0; // inn
    room(74,22,5,4,1); m[22][76]=0; // house
    m[12][74]=3; // save point
    // Grillby's
    room(80,20,6,5,0);
    m[20][82]=1; m[20][83]=1; // partial wall for bar feel

    portals.snowdin = [
      { x:2, y:16, to:'ruins', tx:39, ty:48, label:'Ruins' },
      { x:87, y:16, to:'waterfall', tx:2, ty:27, label:'Waterfall' },
    ];
    npcs.snowdin = [
      { x:60, y:15, name:'Papyrus', dialog:['NYEH HEH HEH!\nI am the GREAT\nPAPYRUS!','I will capture\na human! Then I\'ll\njoin the Royal Guard!','SPAGHETTI!!!'], idx:0, color:'#fff' },
      { x:58, y:17, name:'Sans', dialog:['hey kid.\nwanna hear a joke?','what do you call\na lazy skeleton?\na LAZYBONES.','heh. i crack\nmyself up.'], idx:0, color:'#aaf' },
      { x:75, y:12, name:'Shopkeep', dialog:['Welcome to Snowdin\nShop! We have...\nnothing. Budget cuts.','But the inn next\ndoor still works!'], idx:0, color:'#ff8' },
      { x:82, y:12, name:'Innkeeper', dialog:['Stay the night?\n...It\'s free!','*You feel rested.*'], idx:0, color:'#f8a', healer:true },
      { x:82, y:22, name:'Grillby', dialog:['...............','.......*nods*......','...fire crackles...'], idx:0, color:'#f80' },
    ];
    items.snowdin = [
      { x:20, y:12, name:'Tough Glove', type:'weapon', atk:5, taken:false },
      { x:40, y:14, name:'Nice Cream', type:'heal', hp:15, taken:false },
      { x:48, y:5, name:'Manly Bandana', type:'armor', def:5, taken:false },
      { x:76, y:24, name:'Snowman Piece', type:'heal', hp:45, taken:false },
    ];
    enemySpawns.snowdin = [
      { x:18, y:14, name:'Snowdrake', hp:20, atk:5, exp:12, gold:6, color:'#9cf', respawn:200 },
      { x:38, y:12, name:'Ice Cap', hp:22, atk:6, exp:14, gold:7, color:'#aef', respawn:220 },
      { x:50, y:14, name:'Gyftrot', hp:30, atk:7, exp:20, gold:10, color:'#864', respawn:300 },
      { x:66, y:16, name:'Lesser Dog', hp:18, atk:5, exp:10, gold:5, color:'#ee8', respawn:180 },
    ];
  }

  if (id === 'waterfall') {
    // === WATERFALL (vertical + winding, blue crystals, water streams) ===
    // Entry corridor
    corH(0,12,26,3);
    // First big room with water
    room(10,20,18,14);
    for(let y=24;y<32;y++) for(let x=12;x<16;x++) m[y][x]=2; // water pool
    m[23][14]=7; m[24][14]=7; // bridge over water
    // Crystal corridor north
    corV(8,20,18,3);
    room(12,2,14,8);
    for(let x=14;x<24;x+=3) m[4][x]=11; // crystals on wall
    for(let x=14;x<24;x+=3) m[8][x]=11;
    // Temmie village (hidden east)
    corH(27,38,24,2);
    room(36,20,12,10);
    // Wishing room (south)
    corV(33,44,20,2);
    room(12,40,20,12);
    for(let i=0;i<15;i++) m[42+Math.floor(Math.random()*8)][14+Math.floor(Math.random()*16)]=11; // crystals everywhere
    m[45][22]=3; // save point
    // Undyne chase corridor
    corH(31,50,46,3);
    room(46,40,16,12);
    // Bridge over abyss
    // Bridge over abyss
    for(let x=16;x<=22;x++) { m[48][x]=7; m[49][x]=7; }
    // Boss room
    room(48,2,18,12);
    pillars(48,2,18,12,5);
    corV(8,20,56,2);
    // Exit south
    corV(51,54,54,3);

    portals.waterfall = [
      { x:1, y:27, to:'snowdin', tx:86, ty:16, label:'Snowdin' },
      { x:55, y:54, to:'hotland', tx:30, ty:2, label:'Hotland' },
    ];
    npcs.waterfall = [
      { x:16, y:24, name:'Monster Kid', dialog:['Yo! You going to\nsee Undyne?!','She\'s SO cool!','I wanna be just\nlike her when I\ngrow up!'], idx:0, color:'#ff8' },
      { x:40, y:24, name:'Temmie', dialog:['hOI! im temmie!','temmie love humans!','tem need money\nfor colleg!'], idx:0, color:'#fff' },
      { x:20, y:44, name:'Gerson', dialog:['Wa ha ha!\nI\'ve been here\nsince forever.','Want some tea?\nToo bad, I\'m\nout of cups.'], idx:0, color:'#8a4' },
      { x:55, y:7, name:'Undyne', dialog:['NGAAAAH!\nYou think you can\njust walk through?!','I am UNDYNE,\ncaptain of the\nRoyal Guard!','PREPARE YOURSELF!'], idx:0, color:'#48f' },
    ];
    items.waterfall = [
      { x:20, y:6, name:'Ballet Shoes', type:'weapon', atk:8, taken:false },
      { x:38, y:26, name:'Temmie Flakes', type:'heal', hp:5, taken:false },
      { x:18, y:48, name:'Astronaut Food', type:'heal', hp:30, taken:false },
      { x:60, y:8, name:'Tutu', type:'armor', def:8, taken:false },
    ];
    enemySpawns.waterfall = [
      { x:14, y:28, name:'Aaron', hp:30, atk:8, exp:20, gold:10, color:'#a6f', respawn:250 },
      { x:24, y:24, name:'Woshua', hp:25, atk:7, exp:16, gold:8, color:'#6af', respawn:220 },
      { x:22, y:46, name:'Shyren', hp:28, atk:7, exp:18, gold:9, color:'#aaa', respawn:240 },
      { x:52, y:46, name:'Temmie', hp:20, atk:6, exp:14, gold:7, color:'#fff', respawn:200 },
      { x:55, y:7, name:'BOSS: Undyne', hp:120, atk:14, exp:250, gold:120, color:'#48f', respawn:9999 },
    ];
  }

  if (id === 'hotland') {
    // === HOTLAND / CORE (red, lava, mechanical) ===
    // Entry from top
    room(26,1,8,8);
    m[3][30]=3; // save point
    // Lab
    room(20,10,20,10); pillars(20,10,20,10,6);
    corV(8,10,30,2);
    // Lava sea
    for(let y=22;y<30;y++) for(let x=0;x<z.w;x++) m[y][x]=10;
    // Bridges across lava
    // Bridges across lava
    for(let x=10;x<=20;x++) { m[25][x]=7; m[26][x]=7; }
    for(let x=30;x<=45;x++) { m[25][x]=7; m[26][x]=7; }
    // Platforms in lava
    room(4,24,8,4); room(22,24,6,4); room(48,24,8,4);
    // South: The CORE
    room(20,30,20,6);
    corV(28,35,28,3);
    // Core entrance
    room(15,36,30,10);
    // Core interior maze
    corH(16,25,40,2); corH(30,44,40,2);
    corV(40,44,24,2); corV(40,44,36,2);
    room(20,42,8,6); room(32,42,8,6);
    // Final corridor
    corV(46,49,28,3);
    room(22,48,18,2); // exit hall
    // Mettaton stage
    room(46,36,10,8);
    m[40][50]=3; // save

    portals.hotland = [
      { x:30, y:1, to:'waterfall', tx:55, ty:53, label:'Waterfall' },
      { x:30, y:49, to:'ruins', tx:40, ty:3, label:'New Home (loop)' },
    ];
    npcs.hotland = [
      { x:28, y:14, name:'Alphys', dialog:['O-oh! A human!\nI\'ve been watching\nyou on my cameras!','I-I\'m Dr. Alphys!\nRoyal Scientist!','I can help you\nget through Hotland!'], idx:0, color:'#ff4' },
      { x:49, y:40, name:'Mettaton', dialog:['OH YES! WELCOME\nTO MY SHOW!','RATINGS! DRAMA!\nACTION!','YOU\'RE GOING TO\nBE A STAR, DARLING!'], idx:0, color:'#f4f' },
      { x:24, y:44, name:'Burgerpants', dialog:['I hate my job.\nI hate my life.','...Do you want some\nGlamburgers?\n...Of course not.'], idx:0, color:'#da8' },
      { x:36, y:44, name:'Bratty & Catty', dialog:['Like, OH MY GOD!\nA human!','Do you want to buy\nsome totally legal\nmerchandise?'], idx:0, color:'#f8f' },
    ];
    items.hotland = [
      { x:6, y:25, name:'Burnt Pan', type:'weapon', atk:12, taken:false },
      { x:50, y:25, name:'Stained Apron', type:'armor', def:10, taken:false },
      { x:34, y:44, name:'Glamburger', type:'heal', hp:35, taken:false },
      { x:22, y:44, name:'Starfait', type:'heal', hp:30, taken:false },
      { x:48, y:38, name:'MTT-Brand Steak', type:'heal', hp:50, taken:false },
    ];
    enemySpawns.hotland = [
      { x:24, y:14, name:'Vulkin', hp:30, atk:8, exp:18, gold:10, color:'#f84', respawn:250 },
      { x:36, y:14, name:'Tsunderplane', hp:35, atk:9, exp:22, gold:12, color:'#88f', respawn:280 },
      { x:14, y:25, name:'Pyrope', hp:32, atk:10, exp:20, gold:11, color:'#f60', respawn:260 },
      { x:40, y:42, name:'Knight Knight', hp:45, atk:12, exp:35, gold:18, color:'#aaa', respawn:350 },
      { x:50, y:40, name:'BOSS: Mettaton EX', hp:150, atk:16, exp:300, gold:150, color:'#f4f', respawn:9999 },
    ];
  }

  maps[id] = m;
}

// Generate all maps
Object.keys(ZONES).forEach(id => genMap(id));

// ── Player ──
const P = {
  x: 40, y: 4, zone: 'ruins',
  hp: 30, maxHp: 30, atk: 5, def: 0,
  lv: 1, exp: 0, nextExp: 30, gold: 0,
  weapon: 'Fists', armor: 'None',
  inventory: [{name:'Apple',type:'heal',hp:10},{name:'Apple',type:'heal',hp:10}],
  invMax: 8,
  facing: 0, // 0=down 1=up 2=left 3=right
  stepTimer: 0,
};

// ── Game State ──
const ST = { PLAY:0, DIALOG:1, BATTLE:2, BATTLE_ATK:3, INVENTORY:4, GAME_OVER:5, PICKUP:6, LEVEL_UP:7 };
let state = ST.PLAY;
let dialogLines = [], dialogIdx = 0, dialogName = '';
let battleEnemy = null, battleSel = 0, battleMsg = '', battleTimer = 0, battlePhase = 0; // 0=menu,1=playerAtk,2=enemyAtk,3=result
let invSel = 0;
let pickupMsg = '';
let camX = 0, camY = 0;
let enemyTimers = {}; // respawn tracking
let notification = '', notifyTimer = 0;
let stepCount = 0;
let gameTime = 0;

// ── Helpers ──
function curMap() { return maps[P.zone]; }
function tileAt(x, y) { const m = curMap(); if (y<0||y>=m.length||x<0||x>=m[0].length) return 1; return m[y][x]; }
function solid(t) { return t===1||t===2||t===5||t===10; }
function notify(msg, dur=90) { notification=msg; notifyTimer=dur; }

function checkLevelUp() {
  if (P.exp >= P.nextExp) {
    P.exp -= P.nextExp;
    P.lv++;
    P.maxHp += 5;
    P.hp = P.maxHp;
    P.atk += 2;
    P.nextExp = Math.floor(P.nextExp * 1.5);
    sfxLevelUp();
    notify(`LEVEL UP! LV ${P.lv}`, 120);
  }
}

// ── Update ──
function update() {
  gameTime++;
  if (notifyTimer > 0) notifyTimer--;

  switch (state) {
    case ST.PLAY: {
      let dx=0, dy=0;
      if (keys['ArrowUp']||keys['w']) { dy=-1; P.facing=1; }
      else if (keys['ArrowDown']||keys['s']) { dy=1; P.facing=0; }
      else if (keys['ArrowLeft']||keys['a']) { dx=-1; P.facing=2; }
      else if (keys['ArrowRight']||keys['d']) { dx=1; P.facing=3; }

      if ((dx||dy) && P.stepTimer <= 0) {
        const nx = P.x+dx, ny = P.y+dy;
        if (!solid(tileAt(nx,ny))) {
          P.x=nx; P.y=ny;
          P.stepTimer = 6;
          stepCount++;
          if (stepCount%4===0) sfxStep();

          // Check save points
          if (tileAt(P.x, P.y)===3) {
            P.hp = P.maxHp;
            sfxHeal();
            notify('* The save point fills you with determination.', 120);
          }

          // Check portals
          const ps = portals[P.zone]||[];
          ps.forEach(p => { if(P.x===p.x&&P.y===p.y) { P.zone=p.to; P.x=p.tx; P.y=p.ty; sfxDoor(); const z=ZONES[p.to]; if(z.music)startBgm(z.music);else stopBgm(); notify(p.label); }});

          // Check items
          const itms = items[P.zone]||[];
          itms.forEach(it => {
            if (!it.taken && P.x===it.x && P.y===it.y) {
              if (it.type==='heal' && P.inventory.length < P.invMax) {
                it.taken=true; P.inventory.push({name:it.name,type:'heal',hp:it.hp}); sfxPickup();
                pickupMsg=`Found ${it.name}!`; state=ST.PICKUP;
              } else if (it.type==='weapon') {
                it.taken=true; P.weapon=it.name; P.atk+=it.atk; sfxPickup();
                pickupMsg=`Got ${it.name}! ATK +${it.atk}`; state=ST.PICKUP;
              } else if (it.type==='armor') {
                it.taken=true; P.armor=it.name; P.def+=it.def; sfxPickup();
                pickupMsg=`Got ${it.name}! DEF +${it.def}`; state=ST.PICKUP;
              } else if (it.type==='maxhp') {
                it.taken=true; P.maxHp+=it.hp; P.hp=P.maxHp; sfxPickup();
                pickupMsg=`Got ${it.name}! Max HP +${it.hp}`; state=ST.PICKUP;
              }
            }
          });

          // Check enemy encounters
          const es = enemySpawns[P.zone]||[];
          es.forEach((e,i) => {
            const ek = P.zone+'_'+i;
            if (enemyTimers[ek]>0) return;
            if (Math.abs(P.x-e.x)<=1 && Math.abs(P.y-e.y)<=1) {
              battleEnemy = {...e, idx:i, maxHp:e.hp};
              battleSel=0; battlePhase=0; battleMsg=`A wild ${e.name} appears!`; battleTimer=60;
              state=ST.BATTLE; stopBgm();
              sfxConfirm();
            }
          });
        }
      }
      if (P.stepTimer>0) P.stepTimer--;

      // Z to interact with NPC
      if (jp['z']||jp['Enter']) {
        const ns = npcs[P.zone]||[];
        const fx=[0,0,-1,1], fy=[1,-1,0,0];
        const lx=P.x+fx[P.facing], ly=P.y+fy[P.facing];
        ns.forEach(n => {
          if (n.x===lx && n.y===ly || (n.x===P.x && n.y===P.y)) {
            if (n.healer) {
              P.hp = P.maxHp;
              sfxHeal();
              notify('HP fully restored!');
            } else {
              dialogName=n.name; dialogLines=n.dialog; dialogIdx=0;
              state=ST.DIALOG; sfxConfirm();
            }
          }
        });
      }
      // X to open inventory
      if (jp['x']||jp['Backspace']) {
        state=ST.INVENTORY; invSel=0; sfxSelect();
      }

      // Update enemy respawn timers
      for (const k in enemyTimers) { if(enemyTimers[k]>0) enemyTimers[k]--; }
      break;
    }

    case ST.DIALOG: {
      if (jp['z']||jp['Enter']) {
        dialogIdx++;
        if (dialogIdx >= dialogLines.length) { state=ST.PLAY; } else sfxSelect();
      }
      break;
    }

    case ST.PICKUP: {
      if (jp['z']||jp['Enter']) { state=ST.PLAY; sfxConfirm(); }
      break;
    }

    case ST.LEVEL_UP: {
      if (jp['z']||jp['Enter']) { state=ST.PLAY; sfxConfirm(); }
      break;
    }

    case ST.INVENTORY: {
      if (jp['ArrowUp']||jp['w']) { invSel=Math.max(0,invSel-1); sfxSelect(); }
      if (jp['ArrowDown']||jp['s']) { invSel=Math.min(P.inventory.length,invSel+1); sfxSelect(); }
      if (jp['x']||jp['Backspace']) { state=ST.PLAY; sfxSelect(); }
      if (jp['z']||jp['Enter']) {
        if (invSel < P.inventory.length) {
          const it = P.inventory[invSel];
          if (it.type==='heal') {
            P.hp = Math.min(P.maxHp, P.hp + it.hp);
            P.inventory.splice(invSel,1);
            sfxHeal(); notify(`Used ${it.name}! +${it.hp} HP`);
            if (invSel>=P.inventory.length) invSel=Math.max(0,P.inventory.length-1);
          }
        } else {
          state=ST.PLAY; sfxSelect(); // "Close" option
        }
      }
      break;
    }

    case ST.BATTLE: {
      if (battleTimer>0) { battleTimer--; break; }
      if (battlePhase===0) { // menu
        if (jp['ArrowLeft']||jp['a']) { battleSel=(battleSel+2)%3; sfxSelect(); }
        if (jp['ArrowRight']||jp['d']) { battleSel=(battleSel+1)%3; sfxSelect(); }
        if (jp['z']||jp['Enter']) {
          if (battleSel===0) { // Attack
            const dmg = Math.max(1, P.atk + Math.floor(Math.random()*4) - Math.floor(battleEnemy.atk*0.2));
            battleEnemy.hp = Math.max(0, battleEnemy.hp - dmg);
            battleMsg = `You deal ${dmg} damage!`;
            sfxHit(); battlePhase=1; battleTimer=40;
          } else if (battleSel===1) { // Item
            if (P.inventory.length>0) { state=ST.BATTLE_ATK; invSel=0; sfxSelect(); }
            else { battleMsg='No items!'; battleTimer=30; }
          } else { // Run
            if (battleEnemy.name.startsWith('BOSS')) {
              battleMsg = "Can't run from a boss!"; battleTimer=40;
            } else {
              if (Math.random()<0.6) {
                battleMsg='Got away safely!'; battleTimer=40; battlePhase=3;
              } else {
                battleMsg='Couldn\'t escape!'; battleTimer=30; battlePhase=2;
              }
            }
          }
        }
      } else if (battlePhase===1) { // after player atk
        if (battleEnemy.hp<=0) {
          battleMsg=`Defeated ${battleEnemy.name}!\n+${battleEnemy.exp} EXP  +${battleEnemy.gold} Gold`;
          P.exp+=battleEnemy.exp; P.gold+=battleEnemy.gold;
          const ek = P.zone+'_'+battleEnemy.idx;
          enemyTimers[ek]=battleEnemy.respawn;
          battlePhase=3; battleTimer=60;
          sfxPickup();
          checkLevelUp();
        } else {
          battlePhase=2; battleTimer=20;
        }
      } else if (battlePhase===2) { // enemy attacks
        const dmg = Math.max(1, battleEnemy.atk + Math.floor(Math.random()*3) - P.def);
        P.hp -= dmg;
        battleMsg = `${battleEnemy.name} deals ${dmg}!`;
        sfxHurt(); battleTimer=40;
        if (P.hp<=0) {
          P.hp=0; battlePhase=4; // death
        } else {
          battlePhase=0;
        }
      } else if (battlePhase===3) { // battle end
        state=ST.PLAY;
        const z=ZONES[P.zone]; if(z.music)startBgm(z.music);
      } else if (battlePhase===4) {
        sfxDeath(); state=ST.GAME_OVER;
      }
      break;
    }

    case ST.BATTLE_ATK: { // item select in battle
      if (jp['ArrowUp']||jp['w']) { invSel=Math.max(0,invSel-1); sfxSelect(); }
      if (jp['ArrowDown']||jp['s']) { invSel=Math.min(P.inventory.length-1,invSel+1); sfxSelect(); }
      if (jp['x']||jp['Backspace']) { state=ST.BATTLE; sfxSelect(); }
      if (jp['z']||jp['Enter']) {
        const it = P.inventory[invSel];
        if (it&&it.type==='heal') {
          P.hp=Math.min(P.maxHp,P.hp+it.hp);
          P.inventory.splice(invSel,1);
          battleMsg=`Used ${it.name}! +${it.hp} HP`;
          sfxHeal(); state=ST.BATTLE; battlePhase=2; battleTimer=40;
        }
      }
      break;
    }

    case ST.GAME_OVER: {
      if (jp['z']||jp['Enter']) {
        // Respawn
        P.hp=P.maxHp; P.x=10; P.y=30; P.zone='overworld';
        P.gold=Math.floor(P.gold/2);
        state=ST.PLAY; stopBgm();
        notify('You lost half your gold...',120);
      }
      break;
    }
  }

  // Camera
  camX = P.x * T - W/2 + T/2;
  camY = P.y * T - H/2 + T/2;
  const m = curMap();
  camX = Math.max(0, Math.min(m[0].length*T - W, camX));
  camY = Math.max(0, Math.min(m.length*T - H, camY));

  clearJP();
}

// ── Draw ──
function drawTile(t, sx, sy) {
  const zone = P.zone;
  // Zone-specific floor colors
  if (t===0) {
    if (zone==='ruins') ctx.fillStyle='#4a2866';
    else if (zone==='snowdin') ctx.fillStyle='#e8e8f0';
    else if (zone==='waterfall') ctx.fillStyle='#2a3a5a';
    else if (zone==='hotland') ctx.fillStyle='#553333';
    else ctx.fillStyle='#555';
  } else {
    ctx.fillStyle = TILE_COLORS[t]||'#000';
  }
  ctx.fillRect(sx, sy, T, T);

  // Wall details
  if (t===1) {
    if (zone==='ruins') { ctx.fillStyle='#3a1856'; ctx.fillRect(sx,sy,T,T); ctx.fillStyle='#4a2066'; ctx.fillRect(sx+2,sy+2,T-4,T-4); }
    else if (zone==='snowdin') { ctx.fillStyle='#445'; ctx.fillRect(sx,sy,T,T); ctx.fillStyle='#e8e8f0'; for(let i=0;i<3;i++){ctx.fillRect(sx+Math.random()*24,sy+Math.random()*24,4,4);} }
    else if (zone==='waterfall') { ctx.fillStyle='#1a2a4a'; ctx.fillRect(sx,sy,T,T); ctx.fillStyle='#2a3a5a'; ctx.fillRect(sx+4,sy+4,8,8); }
    else if (zone==='hotland') { ctx.fillStyle='#2a1a1a'; ctx.fillRect(sx,sy,T,T); }
    else { ctx.fillStyle='#222'; ctx.fillRect(sx,sy,T,T); }
  }
  // Water with animation
  if (t===2) {
    ctx.fillStyle='#1a4a8a'; ctx.fillRect(sx,sy,T,T);
    ctx.fillStyle=`rgba(100,180,255,${0.15+Math.sin(gameTime/12+(sx+sy)/30)*0.1})`;
    ctx.fillRect(sx,sy,T,T);
    ctx.fillStyle='rgba(255,255,255,0.1)';
    if((gameTime/15|0)%2===(((sx/T|0)+(sy/T|0))%2)) ctx.fillRect(sx+6,sy+10,14,3);
  }
  // Save point (spinning star)
  if (t===3) {
    if(zone==='ruins') ctx.fillStyle='#4a2866'; else if(zone==='snowdin') ctx.fillStyle='#e8e8f0'; else ctx.fillStyle='#555';
    ctx.fillRect(sx,sy,T,T);
    ctx.fillStyle=`rgba(255,255,0,${0.6+Math.sin(gameTime/8)*0.4})`;
    const cx=sx+16,cy=sy+16,r=6+Math.sin(gameTime/10)*2;
    for(let i=0;i<5;i++){const a=Math.PI*2/5*i-Math.PI/2+gameTime/30;ctx.fillRect(cx+Math.cos(a)*r-2,cy+Math.sin(a)*r-2,4,4);}
    ctx.beginPath();ctx.arc(cx,cy,4,0,Math.PI*2);ctx.fill();
  }
  // Pillar
  if (t===4) {
    if(zone==='ruins'){ctx.fillStyle='#5a3876';ctx.fillRect(sx+6,sy,20,T);ctx.fillStyle='#6a4886';ctx.fillRect(sx+8,sy+2,16,T-4);}
    else if(zone==='snowdin'){ctx.fillStyle='#bbc';ctx.fillRect(sx+8,sy,16,T);} // tree trunk
    else{ctx.fillStyle='#444';ctx.fillRect(sx+8,sy,16,T);}
  }
  // Flowers
  if (t===8) {
    if(zone==='ruins') ctx.fillStyle='#4a2866'; else ctx.fillStyle='#555';
    ctx.fillRect(sx,sy,T,T);
    ctx.fillStyle='#ff0';ctx.beginPath();ctx.arc(sx+10,sy+12,4,0,Math.PI*2);ctx.fill();
    ctx.fillStyle='#fa0';ctx.beginPath();ctx.arc(sx+20,sy+18,3,0,Math.PI*2);ctx.fill();
    ctx.fillStyle='#f44';ctx.beginPath();ctx.arc(sx+14,sy+22,3,0,Math.PI*2);ctx.fill();
  }
  // Ice
  if (t===9) {
    ctx.fillStyle='#8ab4e8';ctx.fillRect(sx,sy,T,T);
    ctx.fillStyle='rgba(255,255,255,0.2)';ctx.fillRect(sx+2,sy+2,12,6);ctx.fillRect(sx+16,sy+18,10,6);
  }
  // Lava
  if (t===10) {
    ctx.fillStyle='#c44';ctx.fillRect(sx,sy,T,T);
    ctx.fillStyle=`rgba(255,100,0,${0.3+Math.sin(gameTime/10+(sx+sy)/20)*0.2})`;ctx.fillRect(sx,sy,T,T);
    ctx.fillStyle='rgba(255,200,50,0.15)';
    if((gameTime/18|0)%3===((sx/T|0)+(sy/T|0))%3) ctx.fillRect(sx+4,sy+8,20,6);
  }
  // Crystal
  if (t===11) {
    if(zone==='waterfall') ctx.fillStyle='#2a3a5a'; else ctx.fillStyle='#555';
    ctx.fillRect(sx,sy,T,T);
    ctx.fillStyle=`rgba(80,160,255,${0.5+Math.sin(gameTime/15+sx/10)*0.3})`;
    ctx.beginPath();ctx.moveTo(sx+16,sy+2);ctx.lineTo(sx+24,sy+20);ctx.lineTo(sx+8,sy+20);ctx.fill();
    ctx.fillStyle=`rgba(150,220,255,${0.3+Math.sin(gameTime/12+sy/10)*0.2})`;
    ctx.beginPath();ctx.moveTo(sx+16,sy+6);ctx.lineTo(sx+20,sy+18);ctx.lineTo(sx+12,sy+18);ctx.fill();
  }
  // Bridge
  if (t===7) {
    ctx.fillStyle='#5a4a3a';ctx.fillRect(sx,sy,T,T);
    ctx.fillStyle='#4a3a2a';ctx.fillRect(sx,sy,T,3);ctx.fillRect(sx,sy+T-3,T,3);
    ctx.fillStyle='#6a5a4a';ctx.fillRect(sx+4,sy+4,T-8,T-8);
  }
}

function drawChar(x, y, color, facing, isPlayer) {
  const sx = x*T - camX, sy = y*T - camY;
  if (sx<-T||sx>W||sy<-T||sy>H) return;
  // Body
  ctx.fillStyle = color;
  ctx.fillRect(sx+8, sy+4, 16, 20);
  // Head
  ctx.fillStyle = isPlayer ? '#fca' : color;
  ctx.fillRect(sx+10, sy, 12, 12);
  // Eyes
  ctx.fillStyle='#000';
  const ex = facing===2?-2:facing===3?2:0;
  ctx.fillRect(sx+12+ex, sy+4, 3, 3);
  ctx.fillRect(sx+17+ex, sy+4, 3, 3);
  // Legs
  ctx.fillStyle = isPlayer ? '#44a' : '#555';
  ctx.fillRect(sx+10, sy+24, 5, 6);
  ctx.fillRect(sx+17, sy+24, 5, 6);
}

function drawBox(x,y,w,h,bg='rgba(0,0,20,0.92)') {
  ctx.fillStyle=bg; ctx.fillRect(x,y,w,h);
  ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h);
}

function txt(text,x,y,color='#fff',size=12) {
  ctx.fillStyle=color; ctx.font=`${size}px 'Press Start 2P',monospace`;
  text.split('\n').forEach((l,i)=>ctx.fillText(l,x,y+i*(size+4)));
}

function drawHPBar(x,y,w,hp,max) {
  ctx.fillStyle='#400'; ctx.fillRect(x,y,w,10);
  ctx.fillStyle=hp>max*0.3?'#0c0':'#f00'; ctx.fillRect(x,y,w*(hp/max),10);
  ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.strokeRect(x,y,w,10);
}

function draw() {
  const z = ZONES[P.zone];
  ctx.fillStyle=z.bg; ctx.fillRect(0,0,W,H);

  const m = curMap();
  const sx0=Math.floor(camX/T), sy0=Math.floor(camY/T);
  const sx1=Math.min(m[0].length-1, sx0+Math.ceil(W/T)+1);
  const sy1=Math.min(m.length-1, sy0+Math.ceil(H/T)+1);

  for(let y=sy0;y<=sy1;y++) for(let x=sx0;x<=sx1;x++) {
    drawTile(m[y][x], x*T-camX, y*T-camY);
  }

  // Items
  (items[P.zone]||[]).forEach(it => {
    if (it.taken) return;
    const sx=it.x*T-camX, sy=it.y*T-camY;
    const bob = Math.sin(gameTime/15)*3;
    ctx.fillStyle='#ff0'; ctx.beginPath(); ctx.arc(sx+16,sy+12+bob,8,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fa0'; ctx.beginPath(); ctx.arc(sx+16,sy+12+bob,5,0,Math.PI*2); ctx.fill();
  });

  // Enemy spawns
  (enemySpawns[P.zone]||[]).forEach((e,i) => {
    const ek = P.zone+'_'+i;
    if (enemyTimers[ek]>0) return;
    drawChar(e.x, e.y, e.color, 0, false);
    const sx=e.x*T-camX;
    const sy=e.y*T-camY;
    txt(e.name.replace('BOSS: ',''), sx-20, sy-6, e.color, 8);
  });

  // NPCs
  (npcs[P.zone]||[]).forEach(n => {
    drawChar(n.x, n.y, n.color, 0, false);
    const sx=n.x*T-camX;
    txt(n.name, sx-10, n.y*T-camY-8, n.color, 8);
  });

  // Portals
  (portals[P.zone]||[]).forEach(p => {
    const sx=p.x*T-camX, sy=p.y*T-camY;
    ctx.fillStyle=`rgba(100,200,255,${0.3+Math.sin(gameTime/10)*0.15})`;
    ctx.fillRect(sx+4,sy+4,24,24);
    txt(p.label, sx-15, sy-6, '#8df', 7);
  });

  // Player
  drawChar(P.x, P.y, '#c44', P.facing, true);

  // HUD
  drawBox(0,H-50,W,50);
  txt(`HP`,8,H-38,'#fff',10);
  drawHPBar(36,H-42,100,P.hp,P.maxHp);
  txt(`${P.hp}/${P.maxHp}`,142,H-38,'#fff',8);
  txt(`LV ${P.lv}  ATK ${P.atk}  DEF ${P.def}  Gold ${P.gold}`,230,H-38,'#ff8',9);
  txt(`${P.zone.toUpperCase()}`,8,H-18,'#aaa',8);
  txt(`[Z] Talk/Save  [X] Items`,260,H-18,'#888',8);

  // Dialog
  if (state===ST.DIALOG) {
    drawBox(20,H-170,W-40,110);
    txt(dialogName,40,H-155,'#ff8',12);
    txt(dialogLines[dialogIdx],40,H-135,'#fff',11);
    txt('▼ Z',W-80,H-75,'#888',9);
  }

  // Pickup
  if (state===ST.PICKUP) {
    drawBox(120,180,400,60);
    txt(pickupMsg,140,210,'#ff0',13);
  }

  // Inventory
  if (state===ST.INVENTORY||state===ST.BATTLE_ATK) {
    drawBox(140,40,360,380);
    txt('INVENTORY',200,65,'#ff8',14);
    P.inventory.forEach((it,i) => {
      const sel = i===invSel;
      txt(`${sel?'> ':'  '}${it.name} (${it.type==='heal'?'+'+it.hp+'HP':it.type})`,160,95+i*24,sel?'#ff0':'#fff',10);
    });
    const ci=P.inventory.length;
    txt(`${ci===invSel?'> ':'  '}Close`,160,95+ci*24,ci===invSel?'#f88':'#aaa',10);
    txt(`${P.inventory.length}/${P.invMax}`,400,65,'#aaa',9);
  }

  // Battle
  if (state===ST.BATTLE||state===ST.BATTLE_ATK) {
    if (state!==ST.BATTLE_ATK) {
      drawBox(0,0,W,H);
      // Enemy
      ctx.fillStyle=battleEnemy.color;
      ctx.beginPath(); ctx.arc(320,120,40+Math.sin(gameTime/8)*3,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#000';
      ctx.beginPath(); ctx.arc(305,110,6,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(335,110,6,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(320,130,10,0,Math.PI); ctx.fill();
      txt(battleEnemy.name,240,30,'#fff',14);
      drawHPBar(220,50,200,battleEnemy.hp,battleEnemy.maxHp);
      txt(`${battleEnemy.hp}/${battleEnemy.maxHp}`,430,56,'#fff',9);
      // Message
      drawBox(40,200,560,80);
      txt(battleMsg,60,230,'#fff',12);
      // Menu
      if (battlePhase===0) {
        const btns=['FIGHT','ITEM','RUN'];
        const cols=['#f44','#4f4','#88f'];
        btns.forEach((b,i) => {
          const bx=120+i*160;
          drawBox(bx,340,130,40,battleSel===i?'#333':'#111');
          txt(b,bx+20,365,cols[i],13);
          if(battleSel===i) { ctx.fillStyle='#f00'; ctx.beginPath(); ctx.arc(bx+8,360,5,0,Math.PI*2); ctx.fill(); }
        });
      }
      // Player stats
      drawBox(40,400,560,60);
      txt(P.name||'Hero',60,425,'#fff',11);
      drawHPBar(160,418,120,P.hp,P.maxHp);
      txt(`${P.hp}/${P.maxHp}`,290,425,'#fff',9);
      txt(`LV ${P.lv}`,400,425,'#ff8',10);
    }
  }

  // Game over
  if (state===ST.GAME_OVER) {
    ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.fillRect(0,0,W,H);
    txt('YOU DIED',210,160,'#f00',28);
    txt('Lost half your gold.',190,230,'#f88',12);
    txt('Press Z to respawn',190,300,'#888',12);
  }

  // Notification
  if (notifyTimer>0) {
    const a = Math.min(1, notifyTimer/15);
    ctx.fillStyle=`rgba(0,0,0,${a*0.7})`;
    ctx.fillRect(W/2-150,10,300,30);
    ctx.fillStyle=`rgba(255,255,100,${a})`;
    ctx.font="11px 'Press Start 2P',monospace";
    ctx.fillText(notification,W/2-140,30);
  }
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
startBgm(ZONES.ruins.music);
loop();
</script>
</body>
</html>
