<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>UNDERTALE - The Ruins</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; background: #000; overflow: hidden; }
body { display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: 'Press Start 2P', monospace; }
canvas { image-rendering: pixelated; touch-action: none; max-width: 100vw; max-height: 70vh; }
#touch { display: none; position: fixed; bottom: 8px; left: 0; right: 0; padding: 0 16px; z-index: 10; justify-content: space-between; align-items: flex-end; }
@media (pointer: coarse) { #touch { display: flex; } }
.pad { display: grid; grid-template: 44px 44px 44px / 44px 44px 44px; gap: 3px; }
.pad button, .act button { background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.35); border-radius: 8px; color: #fff; font-family: 'Press Start 2P'; font-size: 14px; -webkit-user-select: none; user-select: none; touch-action: manipulation; }
.pad button:active, .act button:active { background: rgba(255,255,255,0.3); }
.act { display: flex; flex-direction: column; gap: 8px; }
.act button { width: 56px; height: 56px; border-radius: 50%; font-size: 14px; }
</style>
</head>
<body>
<canvas id="c" width="640" height="480"></canvas>
<div id="touch">
  <div class="pad">
    <button style="grid-column:2;grid-row:1" data-key="Up">▲</button>
    <button style="grid-column:1;grid-row:2" data-key="Left">◀</button>
    <button style="grid-column:3;grid-row:2" data-key="Right">▶</button>
    <button style="grid-column:2;grid-row:3" data-key="Down">▼</button>
  </div>
  <div class="act">
    <button data-key="z" style="background:rgba(255,60,60,0.2);border-color:#f66">Z</button>
    <button data-key="x" style="background:rgba(60,60,255,0.2);border-color:#88f">X</button>
  </div>
</div>
<script>
const cvs = document.getElementById('c'), ctx = cvs.getContext('2d');
const W = 640, H = 480;

// ═══ AUDIO ═══
const ac = new (window.AudioContext || window.webkitAudioContext)();
function resumeAC() { if (ac.state === 'suspended') ac.resume(); }
document.addEventListener('touchstart', resumeAC, { once: true });
document.addEventListener('keydown', resumeAC, { once: true });
function tone(f, d, type = 'square', v = 0.08) {
  try {
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = type; o.frequency.value = f;
    g.gain.setValueAtTime(v, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + d);
    o.connect(g); g.connect(ac.destination); o.start(); o.stop(ac.currentTime + d);
  } catch (e) {}
}
const sfx = {
  select: () => tone(600, 0.04),
  confirm: () => { tone(800, 0.04); setTimeout(() => tone(1200, 0.06), 50); },
  text: () => tone(300 + Math.random() * 150, 0.025, 'square', 0.05),
  hit: () => tone(160, 0.12, 'sawtooth', 0.15),
  hurt: () => { tone(100, 0.15, 'sawtooth', 0.12); setTimeout(() => tone(80, 0.1, 'sawtooth', 0.1), 80); },
  heal: () => { tone(500, 0.06); setTimeout(() => tone(700, 0.06), 60); setTimeout(() => tone(900, 0.08), 120); },
  spare: () => { [600, 800, 1000, 1200].forEach((f, i) => setTimeout(() => tone(f, 0.1), i * 80)); },
  death: () => { [400, 300, 200, 100].forEach((f, i) => setTimeout(() => tone(f, 0.25, 'sawtooth', 0.12), i * 180)); },
};

// ═══ INPUT ═══
const keys = {}, jp = {};
const kmap = { ArrowUp: 'Up', ArrowDown: 'Down', ArrowLeft: 'Left', ArrowRight: 'Right', w: 'Up', s: 'Down', a: 'Left', d: 'Right', ' ': 'z', Enter: 'z', Backspace: 'x' };
document.addEventListener('keydown', e => { const k = kmap[e.key] || e.key.toLowerCase(); if (!keys[k]) jp[k] = true; keys[k] = true; e.preventDefault(); });
document.addEventListener('keyup', e => { keys[kmap[e.key] || e.key.toLowerCase()] = false; });
document.querySelectorAll('[data-key]').forEach(b => {
  const k = b.dataset.key;
  b.addEventListener('touchstart', e => { e.preventDefault(); if (!keys[k]) jp[k] = true; keys[k] = true; });
  b.addEventListener('touchend', e => { e.preventDefault(); keys[k] = false; });
  b.addEventListener('touchcancel', () => { keys[k] = false; });
});

// ═══ HELPERS ═══
function drawBox(x, y, w, h) {
  ctx.fillStyle = '#000'; ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.strokeRect(x, y, w, h);
}
function text(str, x, y, size = 10, col = '#fff') {
  ctx.fillStyle = col; ctx.font = size + 'px "Press Start 2P"';
  str.split('\n').forEach((l, i) => ctx.fillText(l, x, y + i * (size + 6)));
}
function drawHeart(x, y, s = 7) {
  ctx.fillStyle = '#f22';
  ctx.beginPath();
  ctx.moveTo(x, y + s * 0.3);
  ctx.bezierCurveTo(x, y, x - s, y, x - s, y + s * 0.3);
  ctx.bezierCurveTo(x - s, y + s * 0.7, x, y + s, x, y + s * 1.2);
  ctx.bezierCurveTo(x, y + s, x + s, y + s * 0.7, x + s, y + s * 0.3);
  ctx.bezierCurveTo(x + s, y, x, y, x, y + s * 0.3);
  ctx.fill();
}
function hpBar(x, y, w, hp, max) {
  ctx.fillStyle = '#600'; ctx.fillRect(x, y, w, 10);
  ctx.fillStyle = hp > max * 0.25 ? '#ff0' : '#f00'; ctx.fillRect(x, y, w * Math.max(0, hp / max), 10);
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(x, y, w, 10);
}

// ═══ STATES ═══
const S = { INTRO: 0, DIALOG: 1, OVERWORLD: 2, BATTLE: 3, ACT: 4, FIGHT: 5, DODGE: 6, ENEMY_TEXT: 7, GAMEOVER: 8, WIN: 9 };
let state = S.INTRO, frame = 0;

// ═══ DIALOG SYSTEM ═══
let dialogs = [], dlgPage = 0, dlgCharIdx = 0, dlgDone = false, dlgCallback = null;
function startDialog(lines, cb) {
  dialogs = lines; dlgPage = 0; dlgCharIdx = 0; dlgDone = false; dlgCallback = cb || null;
  state = S.DIALOG;
}
function updateDialog() {
  if (!dlgDone) {
    dlgCharIdx += 0.6;
    if (frame % 3 === 0 && dlgCharIdx < dialogs[dlgPage].length) sfx.text();
    if (dlgCharIdx >= dialogs[dlgPage].length) dlgDone = true;
  }
  if (jp['z']) {
    if (!dlgDone) { dlgCharIdx = dialogs[dlgPage].length; dlgDone = true; }
    else {
      dlgPage++;
      if (dlgPage >= dialogs.length) {
        if (dlgCallback) dlgCallback();
        else state = S.OVERWORLD;
      } else { dlgCharIdx = 0; dlgDone = false; }
    }
  }
}
function drawDialog() {
  drawBox(32, H - 180, W - 64, 150);
  const t = dialogs[dlgPage] || '';
  const vis = t.substring(0, Math.floor(dlgCharIdx));
  text(vis, 52, H - 155);
  if (dlgDone) {
    const blink = Math.sin(frame / 8) > 0;
    if (blink) text('▼', W - 80, H - 50, 8, '#aaa');
  }
}

// ═══ PLAYER ═══
const P = { hp: 20, maxHp: 20, atk: 5, lv: 1, name: 'CHARA', inv: ['Monster Candy', 'Monster Candy', 'Spider Cider'] };
const invHeal = { 'Monster Candy': 10, 'Spider Cider': 24, 'Butterscotch Pie': 99 };

// ═══ OVERWORLD ═══
// Rooms: each has a tile map (20x15), NPC positions, etc.
// Simplified: room index, name, description, next/prev, encounter chance
const ROOMS = [
  { name: 'The Beginning', desc: 'A single beam of\nlight shines down\non a bed of flowers.', canFight: false },
  { name: 'Ruins Entrance', desc: 'Purple bricks line\nthe walls.', canFight: false },
  { name: 'Leaf Puzzle', desc: 'Leaves crunch\nunderfoot.', canFight: true, pool: ['froggit'] },
  { name: 'Spike Bridge', desc: 'Sharp spikes\nretract as you\napproach.', canFight: true, pool: ['froggit', 'whimsun'] },
  { name: 'Pillar Room', desc: 'Crumbling pillars\ncast long shadows.', canFight: true, pool: ['whimsun', 'loox'] },
  { name: 'Spider Bake Sale', desc: 'Webs cover the\nwalls. A sign reads:\n"Spider Bake Sale"', canFight: true, pool: ['loox', 'vegetoid'] },
  { name: 'Long Corridor', desc: 'An impossibly long\nhallway stretches\nbefore you.', canFight: true, pool: ['vegetoid', 'froggit'] },
  { name: "Toriel's Home", desc: 'A warm, cozy house.\nThe smell of pie\nfills the air.', canFight: false, save: true },
  { name: 'Basement', desc: 'The corridor grows\ncold. Toriel stands\nat the end.', canFight: false, boss: true },
];
let roomIdx = 0, stepCount = 0, encounterSteps = 12 + Math.floor(Math.random() * 8);
let owPlayerY = H / 2;

// Room colors (Undertale purple theme)
const ROOM_COLORS = ['#1a0530', '#2a0845', '#2a0845', '#2a0845', '#2a0845', '#2a0845', '#2a0845', '#3a1855', '#1a0830'];

function drawOverworld() {
  const r = ROOMS[roomIdx];
  // Background
  ctx.fillStyle = ROOM_COLORS[roomIdx] || '#2a0845';
  ctx.fillRect(0, 0, W, H);
  // Floor
  ctx.fillStyle = '#4a2866';
  ctx.fillRect(80, 60, W - 160, H - 160);
  // Walls
  ctx.fillStyle = '#3a1856';
  for (let x = 60; x < W - 60; x += 32) {
    ctx.fillRect(x, 40, 30, 22);
    ctx.fillRect(x, H - 120, 30, 22);
  }
  for (let y = 40; y < H - 100; y += 32) {
    ctx.fillRect(60, y, 22, 30);
    ctx.fillRect(W - 82, y, 22, 30);
  }
  // Room-specific decorations
  if (roomIdx === 0) {
    // Flower bed
    ctx.fillStyle = '#ff0';
    for (let i = 0; i < 8; i++) {
      const fx = W / 2 - 40 + (i % 4) * 25, fy = H / 2 - 20 + Math.floor(i / 4) * 25;
      ctx.beginPath(); ctx.arc(fx, fy, 5, 0, Math.PI * 2); ctx.fill();
    }
    // Light beam
    ctx.fillStyle = 'rgba(255,255,200,0.08)';
    ctx.beginPath(); ctx.moveTo(W / 2 - 40, 0); ctx.lineTo(W / 2 + 40, 0); ctx.lineTo(W / 2 + 60, H / 2 + 20); ctx.lineTo(W / 2 - 60, H / 2 + 20); ctx.fill();
  }
  if (roomIdx === 7) {
    // Toriel's home - furniture
    ctx.fillStyle = '#6a4a2a';
    ctx.fillRect(150, 100, 80, 50); // table
    ctx.fillStyle = '#8a6a4a';
    ctx.fillRect(400, 90, 60, 70); // bookshelf
    ctx.fillStyle = '#aa4a2a';
    ctx.fillRect(300, 120, 50, 40); // chair
    // Pie
    ctx.fillStyle = '#daa';
    ctx.beginPath(); ctx.arc(190, 115, 12, 0, Math.PI * 2); ctx.fill();
    // Save star
    if (r.save) {
      const glow = 0.5 + Math.sin(frame / 10) * 0.3;
      ctx.fillStyle = `rgba(255,255,0,${glow})`;
      ctx.beginPath(); ctx.arc(W / 2, H / 2 + 60, 8, 0, Math.PI * 2); ctx.fill();
    }
  }
  if (roomIdx === 8) {
    // Dark basement corridor
    ctx.fillStyle = '#1a0830';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#2a1040';
    ctx.fillRect(200, 60, 240, H - 160);
    // Toriel silhouette at end
    ctx.fillStyle = '#fcc';
    ctx.beginPath(); ctx.arc(W / 2, 120, 25, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fcc';
    ctx.fillRect(W / 2 - 15, 140, 30, 40);
    text('Toriel', W / 2 - 30, 85, 8, '#faa');
  }
  // Pillars
  if (roomIdx === 4) {
    for (let i = 0; i < 4; i++) {
      ctx.fillStyle = '#5a3876';
      ctx.fillRect(140 + i * 110, 80, 24, H - 200);
    }
  }
  // Room name
  text(r.name, 20, 25, 10, '#888');
  // Player heart
  drawHeart(W / 2, owPlayerY, 8);
  // Arrows
  if (roomIdx > 0) { text('▲', W / 2 - 5, 50, 10, '#666'); }
  if (roomIdx < ROOMS.length - 1) { text('▼', W / 2 - 5, H - 110, 10, '#666'); }
  // HUD
  drawBox(0, H - 50, W, 50);
  text(`${P.name}  LV ${P.lv}`, 20, H - 30, 8);
  text('HP', 200, H - 30, 8);
  hpBar(230, H - 35, 120, P.hp, P.maxHp);
  text(`${P.hp}/${P.maxHp}`, 360, H - 30, 8);
}

function updateOverworld() {
  let moved = false;
  if (jp['Down'] && roomIdx < ROOMS.length - 1) {
    roomIdx++; moved = true; sfx.select();
    owPlayerY = 100;
  }
  if (jp['Up'] && roomIdx > 0) {
    roomIdx--; moved = true; sfx.select();
    owPlayerY = H - 140;
  }
  // Smooth movement
  const targetY = H / 2;
  owPlayerY += (targetY - owPlayerY) * 0.1;

  if (moved) {
    stepCount++;
    const r = ROOMS[roomIdx];
    // Save
    if (r.save) {
      P.hp = P.maxHp;
      sfx.heal();
      startDialog(["* The smell of\n  butterscotch pie\n  fills you with\n  determination.", "* HP fully restored.\n* Progress saved."], () => { state = S.OVERWORLD; });
      return;
    }
    // Boss
    if (r.boss) {
      startDialog(
        ["* Toriel stands\n  before the exit.", "* She turns to you.", "Prove yourself.\nProve to me that\nyou are strong\nenough to survive."],
        () => startBattle('toriel')
      );
      return;
    }
    // Random encounter
    if (r.canFight && stepCount >= encounterSteps) {
      stepCount = 0;
      encounterSteps = 8 + Math.floor(Math.random() * 10);
      const pool = r.pool || ['froggit'];
      const eid = pool[Math.floor(Math.random() * pool.length)];
      startBattle(eid);
      return;
    }
  }
  // Z to interact
  if (jp['z'] && !moved) {
    const r = ROOMS[roomIdx];
    startDialog([`* ${r.desc}`], () => { state = S.OVERWORLD; });
  }
}

// ═══ BATTLE ═══
const ENEMIES = {
  froggit:  { name: 'Froggit',   hp: 15, atk: 3, color: '#4a4', acts: ['Check', 'Compliment', 'Threaten'], spareable: e => e.acted },
  whimsun:  { name: 'Whimsun',   hp: 10, atk: 2, color: '#dbd', acts: ['Check', 'Console'],              spareable: e => e.acted },
  loox:     { name: 'Loox',      hp: 20, atk: 5, color: '#c84', acts: ['Check', "Don't Pick On"],         spareable: e => e.acted },
  vegetoid: { name: 'Vegetoid',  hp: 18, atk: 4, color: '#6a4', acts: ['Check', 'Compliment', 'Devour'],  spareable: e => e.acted },
  toriel:   { name: 'Toriel',    hp: 80, atk: 7, color: '#fcc', acts: ['Check', 'Talk'],                  spareable: e => e.spareCount >= 8 },
};

let B = { eid: '', hp: 0, maxHp: 0, sel: 0, actSel: 0, text: '', acted: false, spareCount: 0, phase: 'menu' };
let fightBar = 0, fightDir = 1;
let bullets = [], heart = { x: W / 2, y: 300 }, dodgeTimer = 0;
const DODGE_DUR = 150;
const dodgeBox = { x: 120, y: 220, w: 400, h: 130 };

function startBattle(eid) {
  const e = ENEMIES[eid];
  B = { eid, hp: e.hp, maxHp: e.hp, sel: 0, actSel: 0, text: `* ${e.name} blocks\n  the way!`, acted: false, spareCount: 0, phase: 'menu' };
  bullets = [];
  state = S.BATTLE;
  sfx.confirm();
}

function drawEnemy(name, cx, cy) {
  const e = ENEMIES[Object.keys(ENEMIES).find(k => ENEMIES[k].name === name)] || {};
  ctx.fillStyle = e.color || '#aaa';
  const bob = Math.sin(frame / 12) * 4;
  // Body
  if (name === 'Froggit') {
    ctx.beginPath(); ctx.ellipse(cx, cy + bob, 28, 22, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillRect(cx - 25, cy + 18 + bob, 14, 8); ctx.fillRect(cx + 11, cy + 18 + bob, 14, 8);
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx - 8, cy - 5 + bob, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 8, cy - 5 + bob, 4, 0, Math.PI * 2); ctx.fill();
  } else if (name === 'Whimsun') {
    ctx.beginPath(); ctx.ellipse(cx, cy + bob, 10, 16, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx - 20, cy - 5 + bob, 14, 20, -0.3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx + 20, cy - 5 + bob, 14, 20, 0.3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx - 4, cy - 3 + bob, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 4, cy - 3 + bob, 2, 0, Math.PI * 2); ctx.fill();
  } else if (name === 'Loox') {
    ctx.beginPath(); ctx.ellipse(cx, cy + bob, 25, 30, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(cx, cy - 2 + bob, 14, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx, cy - 2 + bob, 8, 0, Math.PI * 2); ctx.fill();
  } else if (name === 'Vegetoid') {
    ctx.beginPath(); ctx.moveTo(cx, cy - 25 + bob); ctx.lineTo(cx + 25, cy + 20 + bob); ctx.lineTo(cx - 25, cy + 20 + bob); ctx.fill();
    ctx.fillStyle = '#0a0';
    ctx.fillRect(cx - 3, cy - 35 + bob, 6, 12);
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx - 8, cy + bob, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 8, cy + bob, 3, 0, Math.PI * 2); ctx.fill();
  } else if (name === 'Toriel') {
    // Robe
    ctx.fillStyle = '#c4a';
    ctx.fillRect(cx - 20, cy - 10 + bob, 40, 50);
    // Head
    ctx.fillStyle = e.color;
    ctx.beginPath(); ctx.arc(cx, cy - 20 + bob, 22, 0, Math.PI * 2); ctx.fill();
    // Ears
    ctx.beginPath(); ctx.ellipse(cx - 18, cy - 38 + bob, 6, 14, -0.2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx + 18, cy - 38 + bob, 6, 14, 0.2, 0, Math.PI * 2); ctx.fill();
    // Eyes
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx - 8, cy - 22 + bob, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 8, cy - 22 + bob, 3, 0, Math.PI * 2); ctx.fill();
    // Mouth
    ctx.beginPath(); ctx.arc(cx, cy - 12 + bob, 5, 0, Math.PI); ctx.stroke();
    // Horns
    ctx.fillStyle = '#fcc';
    ctx.beginPath(); ctx.moveTo(cx - 16, cy - 35 + bob); ctx.lineTo(cx - 20, cy - 50 + bob); ctx.lineTo(cx - 10, cy - 38 + bob); ctx.fill();
    ctx.beginPath(); ctx.moveTo(cx + 16, cy - 35 + bob); ctx.lineTo(cx + 20, cy - 50 + bob); ctx.lineTo(cx + 10, cy - 38 + bob); ctx.fill();
  }
}

function spawnBullets() {
  bullets = [];
  const e = ENEMIES[B.eid];
  const intensity = B.eid === 'toriel' ? Math.max(0.15, 1 - B.spareCount / 10) : 1;
  const count = Math.ceil(({ froggit: 5, whimsun: 7, loox: 8, vegetoid: 6, toriel: 10 }[B.eid] || 5) * intensity);
  
  for (let i = 0; i < count; i++) {
    let b;
    if (B.eid === 'froggit') {
      const a = Math.PI * 2 / count * i;
      b = { x: dodgeBox.x + dodgeBox.w / 2, y: dodgeBox.y + dodgeBox.h / 2, vx: Math.cos(a) * 1.8, vy: Math.sin(a) * 1.8, r: 4 };
    } else if (B.eid === 'whimsun') {
      b = { x: dodgeBox.x + 20 + Math.random() * (dodgeBox.w - 40), y: dodgeBox.y - i * 30, vx: 0, vy: 1.5 + Math.random(), r: 3 };
    } else if (B.eid === 'loox') {
      const a = Math.PI * 2 / count * i + frame / 30;
      const cx = dodgeBox.x + dodgeBox.w / 2, cy = dodgeBox.y + dodgeBox.h / 2;
      b = { x: cx + Math.cos(a) * 60, y: cy + Math.sin(a) * 40, vx: Math.cos(a + 1.5) * 2, vy: Math.sin(a + 1.5) * 2, r: 5 };
    } else if (B.eid === 'vegetoid') {
      b = { x: dodgeBox.x + 30 + Math.random() * (dodgeBox.w - 60), y: dodgeBox.y - 20 - i * 40, vx: (Math.random() - 0.5) * 0.5, vy: 2, r: 5, heal: Math.random() < 0.15 };
    } else if (B.eid === 'toriel') {
      // Fire from sides and top
      if (i % 3 === 0) {
        b = { x: dodgeBox.x + Math.random() * dodgeBox.w, y: dodgeBox.y - 10, vx: 0, vy: 1.5 * intensity, r: 6, fire: true };
      } else if (i % 3 === 1) {
        b = { x: dodgeBox.x - 10, y: dodgeBox.y + Math.random() * dodgeBox.h, vx: 2 * intensity, vy: (Math.random() - 0.5), r: 6, fire: true };
      } else {
        b = { x: dodgeBox.x + dodgeBox.w + 10, y: dodgeBox.y + Math.random() * dodgeBox.h, vx: -2 * intensity, vy: (Math.random() - 0.5), r: 6, fire: true };
      }
    }
    if (b) bullets.push(b);
  }
}

function drawBattle() {
  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
  const e = ENEMIES[B.eid];
  // Enemy
  drawEnemy(e.name, W / 2, 100);
  // Enemy HP
  text(e.name, 30, 30, 10, B.spareCount > 0 && e.spareable(B) ? '#ff0' : '#fff');
  hpBar(30, 45, 180, B.hp, B.maxHp);

  // Main text box
  drawBox(32, 175, W - 64, 100);
  text(B.text, 52, 200, 8);

  if (B.phase === 'menu') {
    const btns = ['FIGHT', 'ACT', 'ITEM', 'MERCY'];
    btns.forEach((b, i) => {
      const bx = 32 + i * 150, by = 380;
      ctx.fillStyle = '#000'; ctx.fillRect(bx, by, 138, 36);
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(bx, by, 138, 36);
      text(b, bx + 15, by + 23, 8, '#f80');
      if (i === B.sel) drawHeart(bx + 6, by + 10, 6);
    });
  }

  if (B.phase === 'act') {
    drawBox(160, 290, 320, 90);
    const acts = e.acts;
    acts.forEach((a, i) => {
      text(`${i === B.actSel ? '> ' : '  '}${a}`, 180, 315 + i * 20, 8, i === B.actSel ? '#fff' : '#aaa');
    });
  }

  if (B.phase === 'item') {
    drawBox(160, 290, 320, 90);
    if (P.inv.length === 0) {
      text('  No items.', 180, 315, 8, '#aaa');
    } else {
      P.inv.forEach((item, i) => {
        if (i < 3) text(`${i === B.actSel ? '> ' : '  '}${item}`, 180, 315 + i * 20, 8, i === B.actSel ? '#fff' : '#aaa');
      });
    }
  }

  if (B.phase === 'fight') {
    ctx.fillStyle = '#333'; ctx.fillRect(80, 300, 480, 30);
    ctx.fillStyle = '#0f0'; ctx.fillRect(80 + fightBar * 480, 300, 12, 30);
    // Center marker
    ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(80 + 240 - 2, 298, 4, 34);
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(80, 300, 480, 30);
  }

  if (B.phase === 'dodge') {
    drawBox(dodgeBox.x, dodgeBox.y, dodgeBox.w, dodgeBox.h);
    // Bullets
    bullets.forEach(b => {
      ctx.fillStyle = b.heal ? '#0f0' : b.fire ? '#f80' : '#fff';
      ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
    });
    // Heart
    drawHeart(heart.x, heart.y, 7);
    // Timer
    const pct = dodgeTimer / DODGE_DUR;
    ctx.fillStyle = '#333'; ctx.fillRect(dodgeBox.x, dodgeBox.y + dodgeBox.h + 8, dodgeBox.w, 6);
    ctx.fillStyle = '#0f0'; ctx.fillRect(dodgeBox.x, dodgeBox.y + dodgeBox.h + 8, dodgeBox.w * pct, 6);
  }

  // Player stats bar
  drawBox(20, H - 50, W - 40, 42);
  text(`${P.name}  LV ${P.lv}`, 40, H - 30, 8);
  text('HP', 250, H - 30, 8);
  hpBar(280, H - 35, 120, P.hp, P.maxHp);
  text(`${P.hp}/${P.maxHp}`, 410, H - 30, 8);
}

function updateBattle() {
  const e = ENEMIES[B.eid];
  
  if (B.phase === 'menu') {
    if (jp['Left']) { B.sel = (B.sel + 3) % 4; sfx.select(); }
    if (jp['Right']) { B.sel = (B.sel + 1) % 4; sfx.select(); }
    if (jp['z']) {
      sfx.confirm();
      if (B.sel === 0) { // FIGHT
        B.phase = 'fight'; fightBar = 0; fightDir = 1;
      } else if (B.sel === 1) { // ACT
        B.phase = 'act'; B.actSel = 0;
      } else if (B.sel === 2) { // ITEM
        B.phase = 'item'; B.actSel = 0;
      } else if (B.sel === 3) { // MERCY
        if (e.spareable(B)) {
          sfx.spare();
          B.text = `* You spared ${e.name}.`;
          B.phase = 'text';
          setTimeout(() => {
            if (B.eid === 'toriel') { state = S.WIN; }
            else { state = S.OVERWORLD; P.exp += e.exp; }
          }, 1500);
        } else {
          B.spareCount++;
          B.text = B.eid === 'toriel' ? `* Toriel stares at\n  you silently.` : `* ${e.name} doesn't\n  want to be\n  spared yet.`;
          startDodge();
        }
      }
    }
  }

  else if (B.phase === 'act') {
    if (jp['Up']) { B.actSel = Math.max(0, B.actSel - 1); sfx.select(); }
    if (jp['Down']) { B.actSel = Math.min(e.acts.length - 1, B.actSel + 1); sfx.select(); }
    if (jp['x']) { B.phase = 'menu'; sfx.select(); return; }
    if (jp['z']) {
      sfx.confirm();
      const act = e.acts[B.actSel];
      if (act === 'Check') {
        B.text = `* ${e.name}\n  ATK ${e.atk}  HP ${B.hp}/${B.maxHp}`;
      } else {
        B.acted = true;
        const responses = {
          'Compliment': `* ${e.name} blushes.`,
          'Threaten': `* ${e.name} shakes\n  with fear.`,
          'Console': `* ${e.name} calms\n  down a little.`,
          "Don't Pick On": `* Loox is relieved.`,
          'Pick On': `* Loox gets angry!`,
          'Devour': `* ...That wasn't\n  very nice.`,
          'Talk': `* You talk to Toriel.\n  She doesn't respond.`,
          'Spare': `* Toriel's attacks\n  grow weaker.`,
        };
        B.text = responses[act] || `* You ${act.toLowerCase()}.`;
        if (act === 'Talk' || act === 'Spare') B.spareCount++;
      }
      startDodge();
    }
  }

  else if (B.phase === 'item') {
    if (jp['Up']) { B.actSel = Math.max(0, B.actSel - 1); sfx.select(); }
    if (jp['Down']) { B.actSel = Math.min(P.inv.length - 1, B.actSel + 1); sfx.select(); }
    if (jp['x']) { B.phase = 'menu'; sfx.select(); return; }
    if (jp['z'] && P.inv.length > 0) {
      const item = P.inv.splice(B.actSel, 1)[0];
      const heal = invHeal[item] || 10;
      P.hp = Math.min(P.maxHp, P.hp + heal);
      sfx.heal();
      B.text = `* You used ${item}.\n  +${heal} HP!`;
      startDodge();
    }
  }

  else if (B.phase === 'fight') {
    fightBar += 0.025 * fightDir;
    if (fightBar >= 1 || fightBar <= 0) fightDir *= -1;
    if (jp['z']) {
      const accuracy = 1 - Math.abs(fightBar - 0.5) * 2; // 0-1, 1=perfect
      const dmg = Math.max(1, Math.floor(P.atk * (0.5 + accuracy * 1.5)));
      B.hp = Math.max(0, B.hp - dmg);
      sfx.hit();
      if (B.hp <= 0) {
        B.text = `* ${e.name} was\n  defeated!\n  +${e.exp} EXP`;
        sfx.death();
        B.phase = 'text';
        setTimeout(() => {
          state = S.OVERWORLD; P.exp += e.exp;
          if (B.eid === 'toriel') state = S.WIN;
        }, 2000);
      } else {
        B.text = `* Hit ${e.name}\n  for ${dmg} damage!`;
        startDodge();
      }
    }
  }

  else if (B.phase === 'dodge') {
    // Move heart
    const spd = heart.speed;
    if (keys['Up']) heart.y -= spd;
    if (keys['Down']) heart.y += spd;
    if (keys['Left']) heart.x -= spd;
    if (keys['Right']) heart.x += spd;
    heart.x = Math.max(dodgeBox.x + 10, Math.min(dodgeBox.x + dodgeBox.w - 10, heart.x));
    heart.y = Math.max(dodgeBox.y + 10, Math.min(dodgeBox.y + dodgeBox.h - 10, heart.y));

    // Update bullets
    bullets.forEach(b => {
      b.x += b.vx; b.y += b.vy;
      if (Math.hypot(b.x - heart.x, b.y - heart.y) < b.r + 6) {
        if (b.heal) {
          P.hp = Math.min(P.maxHp, P.hp + 2);
          b.hit = true;
        } else {
          P.hp -= 1;
          if (frame % 15 === 0) sfx.hurt();
        }
      }
    });
    bullets = bullets.filter(b => !b.hit && b.x > dodgeBox.x - 30 && b.x < dodgeBox.x + dodgeBox.w + 30 && b.y > dodgeBox.y - 30 && b.y < dodgeBox.y + dodgeBox.h + 30);

    // Respawn bullets periodically
    if (frame % 30 === 0) spawnBullets();

    dodgeTimer--;
    if (P.hp <= 0) {
      P.hp = 0; sfx.death(); state = S.GAMEOVER;
    }
    if (dodgeTimer <= 0) {
      B.phase = 'menu';
      B.text = `* ${e.name} watches\n  carefully.`;
      B.sel = 0;
    }
  }
}

function startDodge() {
  B.phase = 'dodge';
  heart.x = dodgeBox.x + dodgeBox.w / 2;
  heart.y = dodgeBox.y + dodgeBox.h / 2;
  heart.speed = 3;
  dodgeTimer = DODGE_DUR;
  bullets = [];
  spawnBullets();
}

// ═══ MAIN UPDATE ═══
function update() {
  frame++;
  if (state === S.INTRO) {
    if (frame > 60 && (jp['z'] || frame > 180)) {
      startDialog([
        "Howdy!",
        "I'm FLOWEY.\nFlowey the Flower!",
        "In this world,\nit's KILL or\nBE KILLED.",
        "That's the only\nway to survive!",
        "...but maybe you\ncan find another\nway.",
        "Good luck,\nlittle one."
      ], () => { state = S.OVERWORLD; roomIdx = 1; });
    }
  }
  else if (state === S.DIALOG) { updateDialog(); }
  else if (state === S.OVERWORLD) { updateOverworld(); }
  else if (state === S.BATTLE || state === S.ACT || state === S.FIGHT || state === S.DODGE) { updateBattle(); }
  else if (state === S.GAMEOVER) {
    if (jp['z']) { P.hp = P.maxHp; state = S.OVERWORLD; frame = 0; }
  }
  else if (state === S.WIN) {
    if (jp['z']) window.location.reload();
  }

  for (const k in jp) delete jp[k];
}

// ═══ MAIN DRAW ═══
function draw() {
  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
  if (state === S.INTRO) {
    ctx.fillStyle = '#2a0845'; ctx.fillRect(0, 0, W, H);
    // Flowey
    const t = frame;
    ctx.fillStyle = '#ff0';
    for (let i = 0; i < 6; i++) {
      const a = Math.PI * 2 / 6 * i + t / 60;
      ctx.beginPath(); ctx.ellipse(W / 2 + Math.cos(a) * 50, H / 2 - 40 + Math.sin(a) * 50, 16, 16, a, 0, Math.PI * 2); ctx.fill();
    }
    ctx.beginPath(); ctx.arc(W / 2, H / 2 - 40, 30, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.fillRect(W / 2 - 10, H / 2 - 48, 6, 6); ctx.fillRect(W / 2 + 5, H / 2 - 48, 6, 6);
    ctx.beginPath(); ctx.arc(W / 2, H / 2 - 32, 7, 0, Math.PI); ctx.fill();
    // Stem
    ctx.fillStyle = '#0a0'; ctx.fillRect(W / 2 - 3, H / 2 - 10, 6, 50);
    text('Press Z', W / 2 - 30, H / 2 + 80, 8, '#888');
  }
  else if (state === S.DIALOG) {
    ctx.fillStyle = '#2a0845'; ctx.fillRect(0, 0, W, H);
    drawDialog();
  }
  else if (state === S.OVERWORLD) { drawOverworld(); }
  else if (state >= S.BATTLE && state <= S.ENEMY_TEXT) { drawBattle(); }
  else if (state === S.GAMEOVER) {
    ctx.fillStyle = 'rgba(0,0,0,0.95)'; ctx.fillRect(0, 0, W, H);
    text('You cannot give\nup just yet...', W / 2 - 80, H / 2 - 40, 14, '#f00');
    text(`${P.name}!`, W / 2 - 30, H / 2 + 20, 14, '#fff');
    text('Stay determined.', W / 2 - 70, H / 2 + 60, 10, '#ff0');
    text('Press Z', W / 2 - 30, H / 2 + 100, 8, '#888');
  }
  else if (state === S.WIN) {
    ctx.fillStyle = '#2a0845'; ctx.fillRect(0, 0, W, H);
    text("You've made it\nthrough the Ruins.", W / 2 - 100, H / 2 - 40, 12, '#fff');
    text('The journey\ncontinues...', W / 2 - 60, H / 2 + 20, 10, '#aaa');
    text('Press Z', W / 2 - 30, H / 2 + 80, 8, '#888');
  }
}

// ═══ LOOP ═══
function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
