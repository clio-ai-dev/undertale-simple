<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Undertale - Ruins Arc</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 640px;
            height: 480px;
            background: #000;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #touchControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: none;
            gap: 10px;
            padding: 10px;
            z-index: 1000;
        }

        #touchControls.visible {
            display: flex;
            justify-content: space-between;
        }

        .touchDPad, .touchButtons {
            display: flex;
            gap: 5px;
        }

        .touchBtn {
            width: 50px;
            height: 50px;
            background: #ff6600;
            border: 2px solid #fff;
            color: #000;
            font-size: 12px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }

        .touchDPadBtn {
            width: 40px;
            height: 40px;
            background: #666;
            border: 2px solid #fff;
            color: #fff;
            font-size: 20px;
            font-family: monospace;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 800px) {
            #gameContainer {
                width: 100vw;
                height: 100vh;
                max-width: 640px;
                max-height: 480px;
            }

            #touchControls.visible {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
        <div id="touchControls">
            <div class="touchDPad">
                <button class="touchDPadBtn" data-key="Up">‚Üë</button>
                <button class="touchDPadBtn" data-key="Down">‚Üì</button>
                <button class="touchDPadBtn" data-key="Left">‚Üê</button>
                <button class="touchDPadBtn" data-key="Right">‚Üí</button>
            </div>
            <div class="touchButtons">
                <button class="touchBtn" data-key="z">Z</button>
                <button class="touchBtn" data-key="x">X</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // UNDERTALE RUINS ARC - FAITHFUL RECREATION
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const TILE_SIZE = 16;
        const FPS = 30;
        const FRAME_TIME = 1000 / FPS;

        // Audio context for Web Audio API
        let audioContext = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // ============================================
        // AUDIO SYNTHESIS
        // ============================================

        function playTone(freq, duration, volume = 0.3) {
            initAudio();
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.value = freq;
            gain.gain.setValueAtTime(volume, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + duration);
        }

        function playMenuSelect() {
            playTone(800, 0.1, 0.2);
        }

        function playTypewriter(charIndex) {
            const pitches = [600, 700, 800, 900, 1000];
            const pitch = pitches[charIndex % pitches.length];
            playTone(pitch, 0.05, 0.15);
        }

        function playHit() {
            playTone(400, 0.15, 0.3);
        }

        function playHurt() {
            playTone(200, 0.2, 0.3);
        }

        function playGameOver() {
            playTone(100, 0.5, 0.3);
        }

        // ============================================
        // GAME STATE
        // ============================================

        const game = {
            state: 'INTRO',
            room: 0,
            playerX: 0,
            playerY: 0,
            playerHP: 20,
            playerMaxHP: 20,
            playerLV: 1,
            inventory: [{ name: 'Pie', heal: 10, quantity: 1 }],
            flags: {
                floweyEncountered: false,
                torielMet: false,
                torielSpareCount: 0,
                inBattle: false,
                gameOver: false,
                won: false,
            },
            currentBattle: null,
            frameCount: 0,
        };

        // ============================================
        // ROOMS
        // ============================================

        const rooms = [
            // Room 0: Flowey's room
            {
                name: 'Flowey Room',
                width: 10,
                height: 9,
                tiles: Array(90).fill(0),
                playerStart: { x: 5, y: 7 },
                entities: [
                    { type: 'flowey', x: 5, y: 3, name: 'Flowey' }
                ],
                exits: [
                    { x: 5, y: 8, to: 1, startY: 1 }
                ],
                hazards: [],
                description: 'A small room with a single golden flower...',
            },
            // Room 1: Tutorial corridor
            {
                name: 'Corridor',
                width: 10,
                height: 15,
                tiles: Array(150).fill(0),
                playerStart: { x: 5, y: 2 },
                entities: [
                    { type: 'npc', x: 5, y: 6, name: 'Toriel', sprite: 'üë©' }
                ],
                exits: [
                    { x: 5, y: 0, to: 0, startY: 8 },
                    { x: 5, y: 14, to: 2, startY: 1 }
                ],
                hazards: [],
                description: 'A long stone corridor.',
            },
            // Room 2: Spider webbing room
            {
                name: 'Spider Room',
                width: 12,
                height: 10,
                tiles: Array(120).fill(0),
                playerStart: { x: 6, y: 2 },
                entities: [],
                exits: [
                    { x: 6, y: 0, to: 1, startY: 14 },
                    { x: 6, y: 9, to: 3, startY: 1 }
                ],
                hazards: [],
                description: 'Spider webs cover the walls...',
                randomEncounter: true,
            },
            // Room 3: Puzzle room 1 (spike switches)
            {
                name: 'Puzzle Room 1',
                width: 12,
                height: 10,
                tiles: Array(120).fill(0),
                playerStart: { x: 2, y: 7 },
                entities: [
                    { type: 'switch', x: 10, y: 7, state: false, id: 'switch1' }
                ],
                exits: [
                    { x: 6, y: 0, to: 2, startY: 9 },
                    { x: 6, y: 9, to: 4, startY: 1 }
                ],
                hazards: [
                    { x: 6, y: 4, width: 6, height: 3, active: true, id: 'spikes1' }
                ],
                description: 'A puzzle with spikes and a distant switch...',
            },
            // Room 4: Puzzle room 2 (boulder push)
            {
                name: 'Puzzle Room 2',
                width: 12,
                height: 10,
                tiles: Array(120).fill(0),
                playerStart: { x: 2, y: 7 },
                entities: [
                    { type: 'boulder', x: 5, y: 7, id: 'boulder1' }
                ],
                exits: [
                    { x: 6, y: 0, to: 3, startY: 9 },
                    { x: 6, y: 9, to: 5, startY: 1 }
                ],
                hazards: [
                    { x: 10, y: 6, width: 2, height: 4, active: true, id: 'hole1' }
                ],
                description: 'A boulder blocks the way...',
            },
            // Room 5: Long corridor with encounters
            {
                name: 'Long Corridor',
                width: 10,
                height: 20,
                tiles: Array(200).fill(0),
                playerStart: { x: 5, y: 2 },
                entities: [],
                exits: [
                    { x: 5, y: 0, to: 4, startY: 9 },
                    { x: 5, y: 19, to: 6, startY: 1 }
                ],
                hazards: [],
                randomEncounter: true,
                description: 'A very long corridor...',
            },
            // Room 6: Toriel's home (living room)
            {
                name: "Toriel's Home",
                width: 12,
                height: 12,
                tiles: Array(144).fill(0),
                playerStart: { x: 6, y: 10 },
                entities: [
                    { type: 'npc', x: 6, y: 3, name: 'Toriel', sprite: 'üë©' },
                    { type: decoration', x: 2, y: 8, sprite: 'ü™ë' },
                    { type: 'savepoint', x: 6, y: 12, name: 'Save Point' }
                ],
                exits: [
                    { x: 6, y: 0, to: 5, startY: 19 },
                    { x: 11, y: 6, to: 7, startY: 6, requiresInteraction: true }
                ],
                hazards: [],
                description: "Toriel's warm home...",
            },
            // Room 7: Toriel's bedroom (pre-boss)
            {
                name: "Toriel's Bedroom",
                width: 10,
                height: 10,
                tiles: Array(100).fill(0),
                playerStart: { x: 1, y: 5 },
                entities: [
                    { type: 'boss', name: 'Toriel', x: 8, y: 5 }
                ],
                exits: [],
                hazards: [],
                description: 'Toriel stands before you...',
            },
        ];

        // ============================================
        // ENEMY DEFINITIONS
        // ============================================

        const enemyTypes = {
            froggit: {
                name: 'Froggit',
                hp: 8,
                sprite: 'üê∏',
                acts: ['Check', 'Compliment', 'Threaten'],
                actEffect: {
                    'Check': 'A small frog. Looks weak.',
                    'Compliment': 'Froggit looks happy.',
                    'Threaten': 'Froggit seems scared.',
                },
                bulletPattern: 'froggit',
                damage: 3,
            },
            whimsun: {
                name: 'Whimsun',
                hp: 6,
                sprite: 'ü¶ã',
                acts: ['Check', 'Terrorize', 'Console'],
                actEffect: {
                    'Check': 'A small moth. Fluttering aimlessly.',
                    'Terrorize': 'Whimsun is terrified.',
                    'Console': 'Whimsun feels comforted.',
                },
                bulletPattern: 'whimsun',
                damage: 2,
            },
            loox: {
                name: 'Loox',
                hp: 7,
                sprite: 'üëÅÔ∏è',
                acts: ['Check', "Don't Pick On", 'Pick On'],
                actEffect: {
                    'Check': 'A floating eye. Stares at you.',
                    "Don't Pick On": "Loox doesn't feel threatened.",
                    'Pick On': 'Loox feels hurt.',
                },
                bulletPattern: 'loox',
                damage: 4,
            },
            vegetoid: {
                name: 'Vegetoid',
                hp: 10,
                sprite: 'ü•ï',
                acts: ['Check', 'Dinner', 'Devour'],
                actEffect: {
                    'Check': 'A sentient vegetable.',
                    'Dinner': 'Vegetoid seems interested.',
                    'Devour': 'You want to eat it.',
                },
                bulletPattern: 'vegetoid',
                damage: 5,
                hasHealing: true,
            },
            toriel: {
                name: 'Toriel',
                hp: 80,
                sprite: 'üë©',
                isBoss: true,
                bulletPattern: 'toriel',
                damage: 8,
            },
        };

        // ============================================
        // INPUT HANDLING
        // ============================================

        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.key.toUpperCase()] === undefined ? keys[e.key.toUpperCase()] = true : void 0;
            if (['ARROWUP', 'ARROWDOWN', 'ARROWLEFT', 'ARROWRIGHT', 'Z', 'X'].includes(e.key.toUpperCase())) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toUpperCase()] = false;
        });

        // Touch controls
        document.querySelectorAll('.touchBtn, .touchDPadBtn').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const key = btn.dataset.key.toUpperCase();
                keys[key] = true;
            });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                const key = btn.dataset.key.toUpperCase();
                keys[key] = false;
            });
        });

        // Show touch controls on touch devices
        if (window.matchMedia('(pointer: coarse)').matches) {
            document.getElementById('touchControls').classList.add('visible');
        }

        // ============================================
        // TEXT RENDERING (TYPEWRITER)
        // ============================================

        class TypewriterText {
            constructor(lines, onComplete = null) {
                this.lines = lines;
                this.currentLine = 0;
                this.currentChar = 0;
                this.framesSinceLastChar = 0;
                this.charFrameDelay = 2;
                this.onComplete = onComplete;
                this.done = false;
            }

            update() {
                if (this.done) return;

                if (this.framesSinceLastChar >= this.charFrameDelay) {
                    playTypewriter(this.currentChar);
                    this.currentChar++;
                    this.framesSinceLastChar = 0;

                    if (this.currentChar > this.lines[this.currentLine].length) {
                        this.currentLine++;
                        this.currentChar = 0;
                        if (this.currentLine >= this.lines.length) {
                            this.done = true;
                            if (this.onComplete) this.onComplete();
                        }
                    }
                } else {
                    this.framesSinceLastChar++;
                }
            }

            draw(x, y, maxWidth = 600) {
                ctx.fillStyle = '#fff';
                ctx.font = '16px "Press Start 2P"';
                ctx.textBaseline = 'top';

                let yPos = y;
                for (let i = 0; i <= this.currentLine; i++) {
                    let text = this.lines[i];
                    if (i === this.currentLine) {
                        text = text.slice(0, this.currentChar);
                    }

                    // Wrap text
                    let words = text.split(' ');
                    let line = '';
                    for (let word of words) {
                        let testLine = line + word + ' ';
                        let metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth && line) {
                            ctx.fillText(line, x, yPos);
                            yPos += 20;
                            line = word + ' ';
                        } else {
                            line = testLine;
                        }
                    }
                    ctx.fillText(line, x, yPos);
                    yPos += 20;
                }
            }

            isComplete() {
                return this.done;
            }
        }

        // ============================================
        // BATTLE SYSTEM
        // ============================================

        class Battle {
            constructor(enemies) {
                this.enemies = enemies;
                this.turn = 0;
                this.playerAction = null;
                this.phase = 'menu'; // menu, fight, enemyAttack, itemSelect, actSelect, actionResult
                this.selectedButton = 0;
                this.buttons = ['FIGHT', 'ACT', 'ITEM', 'MERCY'];
                this.currentAct = 0;
                this.currentItem = 0;
                this.fightBar = { x: 150, width: 300, position: 0, speed: 3, active: false };
                this.enemyAttackPhase = null;
                this.bullets = [];
                this.playerPos = { x: 320, y: 400 };
                this.playerRadius = 8;
                this.gameOverMessage = null;
                this.spareAttempts = {};

                enemies.forEach(e => {
                    this.spareAttempts[e.name] = 0;
                });
            }

            update() {
                if (this.phase === 'menu') {
                    this.updateMenu();
                } else if (this.phase === 'fight') {
                    this.updateFight();
                } else if (this.phase === 'enemyAttack') {
                    this.updateEnemyAttack();
                } else if (this.phase === 'actSelect') {
                    this.updateActSelect();
                } else if (this.phase === 'itemSelect') {
                    this.updateItemSelect();
                }

                // Update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    this.bullets[i].update();
                    if (this.bullets[i].isDone()) {
                        this.bullets.splice(i, 1);
                    } else {
                        // Check collision with player
                        const dist = Math.hypot(
                            this.bullets[i].x - this.playerPos.x,
                            this.bullets[i].y - this.playerPos.y
                        );
                        if (dist < this.playerRadius + this.bullets[i].radius) {
                            if (this.bullets[i].damaging) {
                                game.playerHP -= this.bullets[i].damage || 1;
                                playHurt();
                                this.bullets.splice(i, 1);
                            } else if (this.bullets[i].healing) {
                                game.playerHP = Math.min(game.playerHP + 5, game.playerMaxHP);
                                this.bullets.splice(i, 1);
                            }
                        }
                    }
                }

                if (game.playerHP <= 0) {
                    this.gameOverMessage = new TypewriterText([
                        "* But there was no response.",
                        "* You fell to the darkness below."
                    ]);
                    game.flags.gameOver = true;
                    playGameOver();
                    this.phase = 'gameover';
                }
            }

            updateMenu() {
                if (keys['ARROWLEFT']) {
                    this.selectedButton = Math.max(0, this.selectedButton - 1);
                    keys['ARROWLEFT'] = false;
                    playMenuSelect();
                }
                if (keys['ARROWRIGHT']) {
                    this.selectedButton = Math.min(3, this.selectedButton + 1);
                    keys['ARROWRIGHT'] = false;
                    playMenuSelect();
                }

                if (keys['Z']) {
                    keys['Z'] = false;
                    const action = this.buttons[this.selectedButton];

                    if (action === 'FIGHT') {
                        this.phase = 'fight';
                        this.fightBar.active = true;
                    } else if (action === 'ACT') {
                        this.phase = 'actSelect';
                        this.currentAct = 0;
                    } else if (action === 'ITEM') {
                        this.phase = 'itemSelect';
                        this.currentItem = 0;
                    } else if (action === 'MERCY') {
                        // Check if any enemy can be spared
                        const spareableEnemy = this.enemies.find(e => e.canSpare);
                        if (spareableEnemy) {
                            this.enemies = this.enemies.filter(e => e.name !== spareableEnemy.name);
                            if (this.enemies.length === 0) {
                                game.flags.inBattle = false;
                                game.currentBattle = null;
                            }
                            this.phase = 'menu';
                        } else {
                            // Try to flee
                            if (Math.random() > 0.3) {
                                game.flags.inBattle = false;
                                game.currentBattle = null;
                            } else {
                                this.playerAction = 'FLEE_FAIL';
                                this.phase = 'enemyAttack';
                            }
                        }
                    }

                    playMenuSelect();
                }
            }

            updateFight() {
                this.fightBar.position += this.fightBar.speed;
                if (this.fightBar.position > this.fightBar.width) {
                    this.fightBar.position = 0;
                }

                if (keys['Z']) {
                    keys['Z'] = false;
                    const damage = this.calculateDamage();
                    this.enemies[0].hp -= damage;
                    game.playerHP -= 1; // Player takes chip damage

                    if (this.enemies[0].hp <= 0) {
                        this.enemies.shift();
                        if (this.enemies.length === 0) {
                            game.flags.inBattle = false;
                            game.currentBattle = null;
                            return;
                        }
                    }

                    this.phase = 'enemyAttack';
                    this.fightBar.active = false;
                }
            }

            calculateDamage() {
                const barCenter = this.fightBar.width / 2;
                const distance = Math.abs(this.fightBar.position - barCenter);
                const maxDistance = this.fightBar.width / 2;
                const accuracy = Math.max(0, 1 - distance / maxDistance);
                const baseDamage = 5;
                return Math.floor(baseDamage * (0.3 + accuracy * 0.7) + 1);
            }

            updateActSelect() {
                const acts = enemyTypes[this.enemies[0].type].acts;
                if (keys['ARROWUP']) {
                    this.currentAct = Math.max(0, this.currentAct - 1);
                    keys['ARROWUP'] = false;
                    playMenuSelect();
                }
                if (keys['ARROWDOWN']) {
                    this.currentAct = Math.min(acts.length - 1, this.currentAct + 1);
                    keys['ARROWDOWN'] = false;
                    playMenuSelect();
                }

                if (keys['Z']) {
                    keys['Z'] = false;
                    const selectedAct = acts[this.currentAct];
                    this.enemies[0].canSpare = true;
                    this.spareAttempts[this.enemies[0].name]++;

                    if (this.enemies[0].type === 'toriel') {
                        this.spareAttempts['Toriel']++;
                    }

                    this.playerAction = 'ACT: ' + selectedAct;
                    this.phase = 'enemyAttack';
                }
            }

            updateItemSelect() {
                if (keys['ARROWUP']) {
                    this.currentItem = Math.max(0, this.currentItem - 1);
                    keys['ARROWUP'] = false;
                    playMenuSelect();
                }
                if (keys['ARROWDOWN']) {
                    this.currentItem = Math.min(game.inventory.length - 1, this.currentItem + 1);
                    keys['ARROWDOWN'] = false;
                    playMenuSelect();
                }

                if (keys['Z']) {
                    keys['Z'] = false;
                    const item = game.inventory[this.currentItem];
                    game.playerHP = Math.min(game.playerHP + item.heal, game.playerMaxHP);
                    item.quantity--;
                    if (item.quantity === 0) {
                        game.inventory.splice(this.currentItem, 1);
                    }
                    this.playerAction = 'ITEM: ' + item.name;
                    this.phase = 'enemyAttack';
                }
            }

            generateBullets(enemy) {
                const pattern = enemy.type;
                const spareCount = this.spareAttempts[enemy.name] || 0;

                if (pattern === 'froggit') {
                    for (let i = 0; i < 3; i++) {
                        this.bullets.push(new Bullet(
                            320 + Math.cos(i * Math.PI * 2 / 3) * 50,
                            200 + Math.sin(i * Math.PI * 2 / 3) * 50,
                            Math.random() * 2 - 1,
                            Math.random() * 1,
                            'yellow',
                            6,
                            true,
                            2
                        ));
                    }
                } else if (pattern === 'whimsun') {
                    for (let i = 0; i < 4; i++) {
                        this.bullets.push(new Bullet(
                            100 + i * 150,
                            100,
                            0,
                            1.5,
                            'purple',
                            5,
                            true,
                            2
                        ));
                    }
                } else if (pattern === 'loox') {
                    for (let i = 0; i < 4; i++) {
                        const angle = i * Math.PI / 2;
                        this.bullets.push(new Bullet(
                            320 + Math.cos(angle) * 60,
                            200 + Math.sin(angle) * 60,
                            Math.cos(angle) * 1.5,
                            Math.sin(angle) * 1.5,
                            'red',
                            5,
                            true,
                            3
                        ));
                    }
                } else if (pattern === 'vegetoid') {
                    for (let i = 0; i < 5; i++) {
                        this.bullets.push(new Bullet(
                            150 + Math.random() * 340,
                            50,
                            Math.random() * 0.5 - 0.25,
                            2,
                            Math.random() > 0.7 ? 'green' : 'orange',
                            6,
                            true,
                            2,
                            Math.random() > 0.7
                        ));
                    }
                } else if (pattern === 'toriel') {
                    // Toriel's attacks get easier if you spare
                    if (spareCount > 3) {
                        // Fire misses deliberately
                        for (let i = 0; i < 2; i++) {
                            this.bullets.push(new Bullet(
                                50 + i * 500,
                                150,
                                0,
                                2,
                                'orange',
                                8,
                                true,
                                5
                            ));
                        }
                    } else if (spareCount > 1) {
                        // Moderate difficulty
                        for (let i = 0; i < 3; i++) {
                            this.bullets.push(new Bullet(
                                100 + i * 200,
                                100,
                                Math.random() * 1 - 0.5,
                                2,
                                'orange',
                                8,
                                true,
                                4
                            ));
                        }
                    } else {
                        // Hard - wave pattern
                        for (let i = 0; i < 5; i++) {
                            this.bullets.push(new Bullet(
                                150 + i * 80,
                                80 + Math.sin(i * 0.5) * 40,
                                0,
                                2.5,
                                'orange',
                                8,
                                true,
                                5
                            ));
                        }
                    }
                }
            }

            draw() {
                // Battle box
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(50, 50, 540, 250);

                // Enemy area
                ctx.fillStyle = '#fff';
                ctx.font = '16px "Press Start 2P"';
                this.enemies.forEach((enemy, idx) => {
                    ctx.fillText(enemy.name, 70, 70 + idx * 30);
                    ctx.fillText('HP: ' + enemy.hp, 70, 90 + idx * 30);
                });

                // Dodge box
                ctx.strokeRect(50, 300, 540, 150);

                // Player (red heart)
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(this.playerPos.x, this.playerPos.y, this.playerRadius, 0, Math.PI * 2);
                ctx.fill();

                // Bullets
                this.bullets.forEach(bullet => bullet.draw());

                // Bottom UI
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 450, 640, 30);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 450, 640, 30);

                ctx.fillStyle = '#fff';
                ctx.font = '12px "Press Start 2P"';
                ctx.fillText('CHARA LV 1', 10, 460);
                ctx.fillText('HP: ' + game.playerHP + '/' + game.playerMaxHP, 300, 460);

                // HP Bar
                const hpBarX = 400;
                const hpBarWidth = 230;
                const hpPercent = game.playerHP / game.playerMaxHP;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(hpBarX, 458, hpBarWidth, 14);
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(hpBarX, 458, hpBarWidth * hpPercent, 14);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(hpBarX, 458, hpBarWidth, 14);

                // Menu buttons
                if (this.phase === 'menu') {
                    this.drawMenu();
                } else if (this.phase === 'fight') {
                    this.drawFightBar();
                } else if (this.phase === 'actSelect') {
                    this.drawActSelect();
                } else if (this.phase === 'itemSelect') {
                    this.drawItemSelect();
                } else if (this.phase === 'gameover') {
                    if (this.gameOverMessage) {
                        this.gameOverMessage.draw(70, 320);
                    }
                }
            }

            drawMenu() {
                const buttonWidth = 120;
                const buttonHeight = 30;
                const spacing = 10;
                const startX = 50;
                const startY = 320;

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 300, 640, 180);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 300, 640, 180);

                for (let i = 0; i < 4; i++) {
                    const x = startX + (i % 2) * (buttonWidth + spacing);
                    const y = startY + Math.floor(i / 2) * (buttonHeight + spacing);

                    ctx.fillStyle = this.selectedButton === i ? '#ff6600' : '#666';
                    ctx.fillRect(x, y, buttonWidth, buttonHeight);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, buttonWidth, buttonHeight);

                    ctx.fillStyle = '#fff';
                    ctx.font = '10px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.buttons[i], x + buttonWidth / 2, y + 20);
                    ctx.textAlign = 'left';
                }
            }

            drawFightBar() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 300, 640, 180);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 300, 640, 180);

                ctx.fillStyle = '#ffff00';
                ctx.fillRect(this.fightBar.x + this.fightBar.position - 5, 340, 10, 40);

                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.fightBar.x, 340, this.fightBar.width, 40);
            }

            drawActSelect() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 300, 640, 180);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 300, 640, 180);

                const acts = enemyTypes[this.enemies[0].type].acts;
                acts.forEach((act, idx) => {
                    ctx.fillStyle = this.currentAct === idx ? '#ff6600' : '#666';
                    ctx.fillRect(60, 320 + idx * 35, 300, 30);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(60, 320 + idx * 35, 300, 30);

                    ctx.fillStyle = '#fff';
                    ctx.font = '10px "Press Start 2P"';
                    ctx.fillText(act, 70, 335 + idx * 35);
                });
            }

            drawItemSelect() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 300, 640, 180);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 300, 640, 180);

                game.inventory.forEach((item, idx) => {
                    ctx.fillStyle = this.currentItem === idx ? '#ff6600' : '#666';
                    ctx.fillRect(60, 320 + idx * 35, 300, 30);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(60, 320 + idx * 35, 300, 30);

                    ctx.fillStyle = '#fff';
                    ctx.font = '10px "Press Start 2P"';
                    ctx.fillText(item.name + ' x' + item.quantity, 70, 335 + idx * 35);
                });
            }
        }

        class Bullet {
            constructor(x, y, vx, vy, color, radius, damaging = true, damage = 1, healing = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.radius = radius;
                this.damaging = damaging;
                this.damage = damage;
                this.healing = healing;
                this.life = 300;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
            }

            isDone() {
                return this.life <= 0 || this.x < 0 || this.x > 640 || this.y < 0 || this.y > 480;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ============================================
        // OVERWORLD
        // ============================================

        let currentRoom = 0;
        let transitionProgress = 0;
        let fadeOut = false;
        let nextRoom = 0;

        function drawRoom(roomIndex) {
            const room = rooms[roomIndex];

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, 640, 480);

            // Draw decorations/simple tiles
            room.entities.forEach(entity => {
                if (entity.type === 'decoration') {
                    ctx.fillStyle = '#666';
                    ctx.fillText(entity.sprite, entity.x * TILE_SIZE, entity.y * TILE_SIZE);
                }
            });

            // Draw hazards
            room.hazards.forEach(hazard => {
                if (hazard.active) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(hazard.x * TILE_SIZE, hazard.y * TILE_SIZE, hazard.width * TILE_SIZE, hazard.height * TILE_SIZE);
                }
            });

            // Draw NPCs
            room.entities.forEach(entity => {
                if (entity.type === 'npc' || entity.type === 'boss') {
                    ctx.fillStyle = '#fff';
                    ctx.font = '24px "Press Start 2P"';
                    ctx.fillText(entity.sprite, entity.x * TILE_SIZE, entity.y * TILE_SIZE);
                }
            });

            // Draw player (as a child sprite in overworld)
            ctx.fillStyle = '#ffaaaa';
            ctx.fillRect(game.playerX * TILE_SIZE, game.playerY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(game.playerX * TILE_SIZE + TILE_SIZE / 2, game.playerY * TILE_SIZE + 4, 3, 0, Math.PI * 2);
            ctx.fill();

            // Draw UI
            ctx.fillStyle = '#fff';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText(room.name, 10, 20);
            ctx.fillText('HP: ' + game.playerHP + '/' + game.playerMaxHP, 10, 40);
        }

        function updateOverworld() {
            const room = rooms[currentRoom];

            if (keys['ARROWUP']) {
                game.playerY = Math.max(0, game.playerY - 1);
            }
            if (keys['ARROWDOWN']) {
                game.playerY = Math.min(room.height - 1, game.playerY + 1);
            }
            if (keys['ARROWLEFT']) {
                game.playerX = Math.max(0, game.playerX - 1);
            }
            if (keys['ARROWRIGHT']) {
                game.playerX = Math.min(room.width - 1, game.playerX + 1);
            }

            // Check for room exits
            room.exits.forEach(exit => {
                if (game.playerX === exit.x && game.playerY === exit.y) {
                    nextRoom = exit.to;
                    game.playerY = exit.startY;
                    fadeOut = true;
                    game.state = 'TRANSITION';
                }
            });

            // Check for hazards
            room.hazards.forEach(hazard => {
                if (hazard.active &&
                    game.playerX >= hazard.x && game.playerX < hazard.x + hazard.width &&
                    game.playerY >= hazard.y && game.playerY < hazard.y + hazard.height) {
                    game.playerHP -= 1;
                    playHurt();
                    game.playerY = Math.max(0, game.playerY - 1);
                }
            });

            // Random encounters
            if (room.randomEncounter && Math.random() < 0.005) {
                const enemyPool = ['froggit', 'whimsun', 'loox', 'vegetoid'];
                const chosen = enemyPool[Math.floor(Math.random() * enemyPool.length)];
                const enemyDef = enemyTypes[chosen];
                const enemies = [{ ...enemyDef, type: chosen, canSpare: false }];
                game.currentBattle = new Battle(enemies);
                game.flags.inBattle = true;
                game.state = 'BATTLE';
            }

            // Interactions with NPCs/story
            if (keys['Z']) {
                keys['Z'] = false;

                if (currentRoom === 0 && !game.flags.floweyEncountered) {
                    // Flowey encounter
                    game.flags.floweyEncountered = true;
                    const enemies = [{ ...enemyTypes.froggit, type: 'froggit', canSpare: false }];
                    game.currentBattle = new Battle(enemies);
                    game.flags.inBattle = true;
                    game.state = 'BATTLE';
                } else if (currentRoom === 7) {
                    // Toriel boss
                    const enemies = [{ ...enemyTypes.toriel, type: 'toriel', canSpare: false }];
                    game.currentBattle = new Battle(enemies);
                    game.flags.inBattle = true;
                    game.state = 'BATTLE';
                }
            }
        }

        // ============================================
        // MAIN GAME LOOP
        // ============================================

        let lastFrameTime = 0;

        function gameLoop(currentTime) {
            const elapsed = currentTime - lastFrameTime;

            if (elapsed >= FRAME_TIME) {
                lastFrameTime = currentTime;
                game.frameCount++;

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 640, 480);

                if (game.state === 'INTRO') {
                    updateIntro();
                    drawIntro();
                } else if (game.state === 'OVERWORLD') {
                    if (!game.flags.gameOver) {
                        updateOverworld();
                    }
                    drawRoom(currentRoom);
                } else if (game.state === 'BATTLE') {
                    if (game.currentBattle) {
                        game.currentBattle.update();
                        game.currentBattle.draw();
                    }
                } else if (game.state === 'TRANSITION') {
                    handleTransition();
                    drawRoom(currentRoom);

                    if (transitionProgress < 60) {
                        const alpha = transitionProgress / 60;
                        ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                        ctx.fillRect(0, 0, 640, 480);
                    }
                }

                if (game.flags.gameOver) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, 640, 480);
                    ctx.fillStyle = '#fff';
                    ctx.font = '16px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', 320, 240);
                    ctx.textAlign = 'left';
                }

                if (game.flags.won) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, 640, 480);
                    ctx.fillStyle = '#fff';
                    ctx.font = '16px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText('YOU ESCAPED THE RUINS', 320, 240);
                    ctx.textAlign = 'left';
                }
            }

            requestAnimationFrame(gameLoop);
        }

        let introText = null;
        function updateIntro() {
            if (!introText) {
                introText = new TypewriterText([
                    "* The flowers are growing",
                    "  back...",
                    "* The end of the Ruins.",
                    "",
                    "* A place where humans",
                    "  are not welcome."
                ], () => {
                    if (keys['Z']) {
                        game.state = 'OVERWORLD';
                        currentRoom = 0;
                        game.playerX = rooms[0].playerStart.x;
                        game.playerY = rooms[0].playerStart.y;
                    }
                });
            }

            introText.update();

            if (introText.isComplete() && keys['Z']) {
                keys['Z'] = false;
                game.state = 'OVERWORLD';
                currentRoom = 0;
                game.playerX = rooms[0].playerStart.x;
                game.playerY = rooms[0].playerStart.y;
            }
        }

        function drawIntro() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, 640, 480);

            if (introText) {
                introText.draw(50, 200);
            }

            ctx.fillStyle = '#fff';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('Press Z to continue...', 200, 450);
        }

        function handleTransition() {
            transitionProgress++;

            if (transitionProgress > 120) {
                currentRoom = nextRoom;
                game.playerX = rooms[nextRoom].playerStart.x;
                game.playerY = rooms[nextRoom].playerStart.y;
                game.state = 'OVERWORLD';
                transitionProgress = 0;
                fadeOut = false;
            }
        }

        // Start game
        game.state = 'INTRO';
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
